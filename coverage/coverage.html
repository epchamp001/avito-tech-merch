
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>merch-store: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">avito-tech-merch/cmd/merch-store/main.go (0.0%)</option>
				
				<option value="file1">avito-tech-merch/docs/docs.go (0.0%)</option>
				
				<option value="file2">avito-tech-merch/internal/app/closer.go (0.0%)</option>
				
				<option value="file3">avito-tech-merch/internal/app/routes.go (0.0%)</option>
				
				<option value="file4">avito-tech-merch/internal/app/server.go (0.0%)</option>
				
				<option value="file5">avito-tech-merch/internal/config/config.go (0.0%)</option>
				
				<option value="file6">avito-tech-merch/internal/config/storage.go (0.0%)</option>
				
				<option value="file7">avito-tech-merch/internal/controller/http/auth_controller.go (100.0%)</option>
				
				<option value="file8">avito-tech-merch/internal/controller/http/controller.go (0.0%)</option>
				
				<option value="file9">avito-tech-merch/internal/controller/http/merch_controller.go (100.0%)</option>
				
				<option value="file10">avito-tech-merch/internal/controller/http/middleware/jwt_auth_middleware.go (0.0%)</option>
				
				<option value="file11">avito-tech-merch/internal/controller/http/purchase_controller.go (85.7%)</option>
				
				<option value="file12">avito-tech-merch/internal/controller/http/transaction_controller.go (100.0%)</option>
				
				<option value="file13">avito-tech-merch/internal/controller/http/user_controller.go (100.0%)</option>
				
				<option value="file14">avito-tech-merch/internal/metrics/business_metrics.go (0.0%)</option>
				
				<option value="file15">avito-tech-merch/internal/metrics/db_metrics.go (0.0%)</option>
				
				<option value="file16">avito-tech-merch/internal/metrics/http_metrics.go (0.0%)</option>
				
				<option value="file17">avito-tech-merch/internal/models/dto/merch_dto.go (100.0%)</option>
				
				<option value="file18">avito-tech-merch/internal/models/dto/purchase_dto.go (100.0%)</option>
				
				<option value="file19">avito-tech-merch/internal/models/dto/transaction_dto.go (100.0%)</option>
				
				<option value="file20">avito-tech-merch/internal/models/dto/user_dto.go (100.0%)</option>
				
				<option value="file21">avito-tech-merch/internal/service/auth_service.go (96.2%)</option>
				
				<option value="file22">avito-tech-merch/internal/service/merch_service.go (100.0%)</option>
				
				<option value="file23">avito-tech-merch/internal/service/mock/Service.go (0.0%)</option>
				
				<option value="file24">avito-tech-merch/internal/service/purchase_service.go (83.8%)</option>
				
				<option value="file25">avito-tech-merch/internal/service/service.go (0.0%)</option>
				
				<option value="file26">avito-tech-merch/internal/service/transaction_service.go (87.5%)</option>
				
				<option value="file27">avito-tech-merch/internal/service/user_service.go (100.0%)</option>
				
				<option value="file28">avito-tech-merch/internal/storage/db/mock/Executor.go (0.0%)</option>
				
				<option value="file29">avito-tech-merch/internal/storage/db/mock/MerchRepository.go (0.0%)</option>
				
				<option value="file30">avito-tech-merch/internal/storage/db/mock/PurchaseRepository.go (0.0%)</option>
				
				<option value="file31">avito-tech-merch/internal/storage/db/mock/Repository.go (0.0%)</option>
				
				<option value="file32">avito-tech-merch/internal/storage/db/mock/TransactionRepository.go (0.0%)</option>
				
				<option value="file33">avito-tech-merch/internal/storage/db/mock/TxManager.go (0.0%)</option>
				
				<option value="file34">avito-tech-merch/internal/storage/db/mock/UserRepository.go (0.0%)</option>
				
				<option value="file35">avito-tech-merch/internal/storage/db/postgres/merch_repository.go (0.0%)</option>
				
				<option value="file36">avito-tech-merch/internal/storage/db/postgres/purchase_repository.go (0.0%)</option>
				
				<option value="file37">avito-tech-merch/internal/storage/db/postgres/transaction_repository.go (0.0%)</option>
				
				<option value="file38">avito-tech-merch/internal/storage/db/postgres/tx_manager.go (0.0%)</option>
				
				<option value="file39">avito-tech-merch/internal/storage/db/postgres/user_repository.go (0.0%)</option>
				
				<option value="file40">avito-tech-merch/internal/storage/db/repository.go (0.0%)</option>
				
				<option value="file41">avito-tech-merch/pkg/jwt/jwt.go (0.0%)</option>
				
				<option value="file42">avito-tech-merch/pkg/jwt/mock/TokenService.go (0.0%)</option>
				
				<option value="file43">avito-tech-merch/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file44">avito-tech-merch/pkg/logger/mock/Logger.go (0.0%)</option>
				
				<option value="file45">avito-tech-merch/pkg/password/hash_password.go (83.3%)</option>
				
				<option value="file46">avito-tech-merch/tests/integration/testutil/migrate.go (0.0%)</option>
				
				<option value="file47">avito-tech-merch/tests/integration/testutil/postgres_container.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        _ "avito-tech-merch/docs"
        "avito-tech-merch/internal/app"
        "avito-tech-merch/internal/config"
        "avito-tech-merch/pkg/logger"
        "context"
        "os"
        "os/signal"
        "syscall"
        "time"
)

// @title Merch Store
// @version 1.0
// @description This is a service that will allow employees to exchange coins and purchase merch with them.

// @contact.name Egor Ponyaev
// @contact.url https://github.com/epchamp001
// @contact.email epchamp001@gmail.com

// @license.name MIT

// @host localhost:8080
// @BasePath /api

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description JWT token
func main() <span class="cov0" title="0">{
        ctx, stop := signal.NotifyContext(context.Background(),
                os.Interrupt, syscall.SIGTERM, syscall.SIGQUIT)
        defer stop()

        cfg, err := config.LoadConfig("configs/", ".env")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">log := logger.NewLogger(cfg.Env)
        defer log.Sync()

        server := app.NewServer(cfg, log)

        if err := server.Run(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalw("Failed to start server",
                        "error", err,
                )
        }</span>

        <span class="cov0" title="0">&lt;-ctx.Done()

        shutdownCtx, cancel := context.WithTimeout(
                context.Background(),
                time.Duration(cfg.PublicServer.ShutdownTimeout)*time.Second,
        )
        defer cancel()

        if err := server.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                log.Errorw("Shutdown failed",
                        "error", err,
                )
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">log.Info("Application stopped gracefully")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "Egor Ponyaev",
            "url": "https://github.com/epchamp001",
            "email": "epchamp001@gmail.com"
        },
        "license": {
            "name": "MIT"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Login a user with username and password, returns a JWT token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Login a user",
                "parameters": [
                    {
                        "description": "User login data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "JWT token",
                        "schema": {
                            "$ref": "#/definitions/dto.AuthResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse400"
                        }
                    },
                    "401": {
                        "description": "Invalid credentials",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponseInvalidCredentials401"
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Register a new user with username and password, returns a JWT token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Register a new user",
                "parameters": [
                    {
                        "description": "User registration data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.RegisterRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "JWT token",
                        "schema": {
                            "$ref": "#/definitions/dto.AuthResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse400"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse500"
                        }
                    }
                }
            }
        },
        "/info": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Fetches user information based on the userID from the context",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "user"
                ],
                "summary": "Get user information",
                "responses": {
                    "200": {
                        "description": "User information",
                        "schema": {
                            "$ref": "#/definitions/dto.UserInfoResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponseUnauthorized401"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse500"
                        }
                    }
                }
            }
        },
        "/merch": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Fetches all merch items from the database and returns a list of merch",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "merch"
                ],
                "summary": "Get list of merchandise items",
                "responses": {
                    "200": {
                        "description": "List of merchandise items",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dto.MerchDTO"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse500"
                        }
                    }
                }
            }
        },
        "/merch/buy/{item}": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Allows a user to purchase a merchandise item by specifying the item ID in the URL",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "purchase"
                ],
                "summary": "Purchase a merchandise item",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Item ID to purchase",
                        "name": "item",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Purchase successful",
                        "schema": {
                            "$ref": "#/definitions/dto.PurchaseSuccessResponse"
                        }
                    },
                    "400": {
                        "description": "Bad request (item is required)",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse400"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponseUnauthorized401"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse500"
                        }
                    }
                }
            }
        },
        "/send-coin": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Allows a user to send coins to another user by specifying the receiver ID and the amount",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "transaction"
                ],
                "summary": "Transfer coins between users",
                "parameters": [
                    {
                        "description": "Transfer request data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.TransferRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Coins transferred successfully",
                        "schema": {
                            "$ref": "#/definitions/dto.TransferSuccessResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request (missing or invalid data)",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse400"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponseUnauthorized401"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse500"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "dto.AuthResponse": {
            "description": "Response containing JWT token",
            "type": "object",
            "properties": {
                "token": {
                    "type": "string",
                    "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njg5NTEwMTcsInN1YiI6ImpvaG5AZG9lLmNvbSJ9.Q3k6yMFYtuzPyjoZYpIHibJQPey29QWmlHfwS2A3keM"
                }
            }
        },
        "dto.ErrorResponse400": {
            "description": "The standard API error format for 400 Bad Request",
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 400
                },
                "message": {
                    "type": "string",
                    "example": "invalid request"
                }
            }
        },
        "dto.ErrorResponse500": {
            "description": "The standard API error format for 500 Internal Server Error",
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 500
                },
                "message": {
                    "type": "string",
                    "example": "server error"
                }
            }
        },
        "dto.ErrorResponseInvalidCredentials401": {
            "description": "The standard API error format for 401 Unauthorized (invalid credentials)",
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 401
                },
                "message": {
                    "type": "string",
                    "example": "invalid credentials"
                }
            }
        },
        "dto.ErrorResponseUnauthorized401": {
            "description": "The standard API error format for 401 Unauthorized (general unauthorized error)",
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 401
                },
                "message": {
                    "type": "string",
                    "example": "unauthorized"
                }
            }
        },
        "dto.LoginRequest": {
            "description": "Data for user login",
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "properties": {
                "password": {
                    "type": "string",
                    "example": "strongpassword123"
                },
                "username": {
                    "type": "string",
                    "example": "epchamp001"
                }
            }
        },
        "dto.MerchDTO": {
            "description": "DTO representing merch information",
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer",
                    "example": 2
                },
                "name": {
                    "type": "string",
                    "example": "cup"
                },
                "price": {
                    "type": "integer",
                    "example": 20
                }
            }
        },
        "dto.PurchaseDTO": {
            "description": "DTO representing purchase information",
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string",
                    "example": "2025-02-15T10:00:00"
                },
                "id": {
                    "type": "integer",
                    "example": 1
                },
                "merch_id": {
                    "type": "integer",
                    "example": 3
                },
                "user_id": {
                    "type": "integer",
                    "example": 1
                }
            }
        },
        "dto.PurchaseSuccessResponse": {
            "description": "Response indicating that the purchase was successful",
            "type": "object",
            "properties": {
                "message": {
                    "type": "string",
                    "example": "purchase successful"
                }
            }
        },
        "dto.RegisterRequest": {
            "description": "Data for creating a new user",
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "properties": {
                "password": {
                    "type": "string",
                    "example": "strongpassword123"
                },
                "username": {
                    "type": "string",
                    "example": "epchamp001"
                }
            }
        },
        "dto.TransactionDTO": {
            "description": "DTO representing transaction information",
            "type": "object",
            "properties": {
                "amount": {
                    "type": "integer",
                    "example": 200
                },
                "created_at": {
                    "type": "string",
                    "example": "2025-02-16T14:30:00"
                },
                "id": {
                    "type": "integer",
                    "example": 1
                },
                "receiver_id": {
                    "type": "integer",
                    "example": 2
                },
                "sender_id": {
                    "type": "integer",
                    "example": 1
                }
            }
        },
        "dto.TransferRequest": {
            "description": "Data for transferring coins between users",
            "type": "object",
            "required": [
                "amount",
                "receiver_id"
            ],
            "properties": {
                "amount": {
                    "type": "integer",
                    "example": 100
                },
                "receiver_id": {
                    "type": "integer",
                    "example": 2
                }
            }
        },
        "dto.TransferSuccessResponse": {
            "description": "Response indicating that the coin transfer was successful",
            "type": "object",
            "properties": {
                "message": {
                    "type": "string",
                    "example": "coins transferred successfully"
                }
            }
        },
        "dto.UserInfoResponse": {
            "description": "Response containing user information",
            "type": "object",
            "properties": {
                "balance": {
                    "type": "integer",
                    "example": 1500
                },
                "purchases": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/dto.PurchaseDTO"
                    }
                },
                "transactions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/dto.TransactionDTO"
                    }
                },
                "user_id": {
                    "type": "integer",
                    "example": 1
                },
                "username": {
                    "type": "string",
                    "example": "epchamp001"
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "description": "JWT token",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/api",
        Schemes:          []string{},
        Title:            "Merch Store",
        Description:      "This is a service that will allow employees to exchange coins and purchase merch with them.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "context"
        "fmt"
        "strings"
        "sync"
)

type Func func(ctx context.Context) error

type Closer struct {
        mu    sync.Mutex
        funcs []Func
}

func NewCloser() *Closer <span class="cov0" title="0">{
        return &amp;Closer{}
}</span>

func (c *Closer) Add(f Func) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.funcs = append(c.funcs, f)
}</span>

func (c *Closer) Close(ctx context.Context) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        var (
                msgs    = make([]string, 0, len(c.funcs))
                wg      sync.WaitGroup
                errorCh = make(chan error, len(c.funcs))
                done    = make(chan struct{})
        )

        // Завершаем в порядке LIFO
        for i := len(c.funcs) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(f Func) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        if err := f(ctx); err != nil </span><span class="cov0" title="0">{
                                errorCh &lt;- err
                        }</span>
                }(c.funcs[i])
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(done)
                close(errorCh)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                break</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("shutdown timeout: %v", ctx.Err())</span>
        }

        <span class="cov0" title="0">for err := range errorCh </span><span class="cov0" title="0">{
                msgs = append(msgs, fmt.Sprintf("[!] %v", err))
        }</span>

        <span class="cov0" title="0">if len(msgs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "shutdown completed with errors:\n%s",
                        strings.Join(msgs, "\n"),
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package app

import (
        controller "avito-tech-merch/internal/controller/http"
        "avito-tech-merch/internal/controller/http/middleware"
        "avito-tech-merch/internal/metrics"
        "avito-tech-merch/internal/service"
        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

func SetupRoutes(router *gin.Engine, controller controller.Controller, authService service.Service) <span class="cov0" title="0">{
        authMiddleware := middleware.JWTAuthMiddleware(authService)

        router.Use(metrics.GinPrometheusMiddleware())

        api := router.Group("/api")
        </span><span class="cov0" title="0">{
                api.POST("/auth/register", controller.Register)

                api.POST("/auth/login", controller.Login)

                protected := api.Group("/")
                protected.Use(authMiddleware)
                </span><span class="cov0" title="0">{
                        protected.GET("/info", controller.GetInfo)
                        protected.POST("/send-coin", controller.SendCoin)
                        protected.GET("/merch", controller.ListMerch)
                        protected.POST("/merch/buy/:item", controller.BuyMerch)
                }</span>
        }
        <span class="cov0" title="0">router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package app

import (
        "avito-tech-merch/internal/config"
        controller "avito-tech-merch/internal/controller/http"
        "avito-tech-merch/internal/metrics"
        "avito-tech-merch/internal/service"
        "avito-tech-merch/internal/storage/db"
        "avito-tech-merch/internal/storage/db/postgres"
        "avito-tech-merch/pkg/jwt"
        "avito-tech-merch/pkg/logger"
        "context"
        "errors"
        "fmt"
        "github.com/gin-gonic/gin"
        "github.com/jackc/pgx/v5/pgxpool"
        "net/http"
        "time"
)

type Server struct {
        closer       *Closer
        router       *gin.Engine
        pgPool       *pgxpool.Pool
        config       *config.Config
        httpServer   *http.Server
        metricServer *http.Server
        logger       logger.Logger
}

func NewServer(cfg *config.Config, log logger.Logger) *Server <span class="cov0" title="0">{
        c := NewCloser()

        pgPool, err := cfg.Storage.ConnectionToPostgres(log)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalw("Failed to connect to postgres",
                        "error", err)
        }</span>
        <span class="cov0" title="0">c.Add(func(ctx context.Context) error </span><span class="cov0" title="0">{
                log.Infow("Closing PostgreSQL pool")
                pgPool.Close()
                return nil
        }</span>)

        <span class="cov0" title="0">txManager := postgres.NewTxManager(pgPool, log)

        userRepo := postgres.NewUserRepository(txManager, log)
        merchRepo := postgres.NewMerchRepository(txManager, log)
        purchaseRepo := postgres.NewPurchaseRepository(txManager, log)
        transactionRepo := postgres.NewTransactionRepository(txManager, log)

        repo := db.NewRepository(userRepo, merchRepo, purchaseRepo, transactionRepo)

        tokenService := jwt.NewTokenService()

        authService := service.NewAuthService(repo, log, cfg.JWT, tokenService, txManager)
        userService := service.NewUserService(repo, log, txManager)
        merchService := service.NewMerchService(repo, log)
        purchaseService := service.NewPurchaseService(repo, log, txManager)
        transactionService := service.NewTransactionService(repo, log, txManager)

        serv := service.NewService(authService, userService, merchService, purchaseService, transactionService)

        authController := controller.NewAuthController(serv)
        userController := controller.NewUserController(serv)
        merchController := controller.NewMerchController(serv)
        purchaseController := controller.NewPurchaseController(serv)
        transactionController := controller.NewTransactionController(serv)

        contr := controller.NewController(authController, userController, merchController, purchaseController, transactionController)

        router := gin.Default()
        SetupRoutes(router, contr, serv)

        httpServer := &amp;http.Server{
                Addr:    fmt.Sprintf("%s:%d", cfg.PublicServer.Endpoint, cfg.PublicServer.Port),
                Handler: router,
        }

        metricMux := http.NewServeMux()
        metricMux.Handle("/metrics", metrics.MetricsHandler())
        metricServer := &amp;http.Server{
                Addr:    fmt.Sprintf("%s:%d", cfg.Metrics.Endpoint, cfg.Metrics.Port),
                Handler: metricMux,
        }

        return &amp;Server{
                closer:       c,
                router:       router,
                pgPool:       pgPool,
                config:       cfg,
                httpServer:   httpServer,
                metricServer: metricServer,
                logger:       log,
        }</span>
}

func (s *Server) Run(ctx context.Context) error <span class="cov0" title="0">{
        // Сбор метрик активных соединений
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(10 * time.Second)
                defer ticker.Stop()
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                stats := s.pgPool.Stat()
                                metrics.RecordDBActiveConnections(int(stats.TotalConns()))</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                s.logger.Infow("Stopping DB metrics collection goroutine")
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">s.closer.Add(func(ctx context.Context) error </span><span class="cov0" title="0">{
                s.logger.Infow("Shutting down HTTP server")
                return s.httpServer.Shutdown(ctx)
        }</span>)

        <span class="cov0" title="0">s.closer.Add(func(ctx context.Context) error </span><span class="cov0" title="0">{
                s.logger.Infow("Shutting down Metrics server")
                return s.metricServer.Shutdown(ctx)
        }</span>)

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                s.logger.Infow("Starting HTTP server",
                        "address", s.httpServer.Addr)
                if err := s.httpServer.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        s.logger.Fatalw("HTTP server error",
                                "error", err)
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                s.logger.Infow("Starting Metrics server", "address", s.metricServer.Addr)
                if err := s.metricServer.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        s.logger.Fatalw("Metrics server error",
                                "error", err)
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

func (s *Server) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        return s.closer.Close(ctx)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "fmt"
        "github.com/joho/godotenv"
        "github.com/spf13/viper"
)

type Config struct {
        Env          string             `mapstructure:"env"`
        Application  ApplicationConfig  `mapstructure:"application"`
        PublicServer PublicServerConfig `mapstructure:"public_server"`
        Storage      StorageConfig      `mapstructure:"storage"`
        JWT          JWTConfig          `mapstructure:"jwt"`
        Metrics      MetricsConfig      `mapstructure:"metrics"`
}

func LoadConfig(configPath, envPath string) (*Config, error) <span class="cov0" title="0">{
        err := godotenv.Load(envPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("WARNING: error loading .env file from %s: %v\n", envPath, err)
        }</span>

        <span class="cov0" title="0">viper.SetConfigName("config")
        viper.SetConfigType("yaml")
        viper.AddConfigPath(configPath)

        err = viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading config file from %s: %v", configPath, err)
        }</span>

        <span class="cov0" title="0">viper.AutomaticEnv()

        viper.BindEnv("storage.postgres.hosts", "DB_HOST")
        viper.BindEnv("storage.postgres.password", "DB_PASSWORD")
        viper.BindEnv("storage.redis.host", "REDIS_HOST")
        viper.BindEnv("storage.redis.password", "REDIS_PASSWORD")
        viper.BindEnv("jwt.secret_key", "JWT_SECRET_KEY")

        var config Config
        err = viper.Unmarshal(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to decode into struct: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "avito-tech-merch/pkg/logger"
        "context"
        "fmt"
        "github.com/jackc/pgx/v5/pgxpool"
        _ "github.com/sourcegraph/conc/pool"
        "time"
)

type StorageConfig struct {
        Postgres PostgresConfig `mapstructure:"postgres"`
        Redis    RedisConfig    `mapstructure:"redis"`
}

type PostgresConfig struct {
        Hosts              []string   `mapstructure:"hosts"`
        Port               int        `mapstructure:"port"`
        Database           string     `mapstructure:"database"`
        Username           string     `mapstructure:"username"`
        Password           string     `mapstructure:"password"`
        SSLMode            string     `mapstructure:"ssl_mode"`
        ConnectionAttempts int        `mapstructure:"connection_attempts"`
        Pool               PoolConfig `mapstructure:"pool"`
}

type PoolConfig struct {
        MaxConnections    int `mapstructure:"max_connections"`
        MinConnections    int `mapstructure:"min_connections"`
        MaxLifeTime       int `mapstructure:"max_lifetime"`
        MaxIdleTime       int `mapstructure:"max_idle_time"`
        HealthCheckPeriod int `mapstructure:"health_check_period"`
}

type RedisConfig struct {
        Host     []string `mapstructure:"host"`
        Port     int      `mapstructure:"port"`
        Password string   `mapstructure:"password"`
        DB       int      `mapstructure:"db"`
}

func (s *StorageConfig) ConnectionToPostgres(log logger.Logger) (*pgxpool.Pool, error) <span class="cov0" title="0">{
        cfg := s.Postgres
        dsn := s.GetDSN()

        poolConfig, err := pgxpool.ParseConfig(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse postgres DSN: %w", err)
        }</span>

        <span class="cov0" title="0">poolConfig.MaxConns = int32(cfg.Pool.MaxConnections)
        poolConfig.MinConns = int32(cfg.Pool.MinConnections)
        poolConfig.MaxConnLifetime = time.Duration(cfg.Pool.MaxLifeTime)
        poolConfig.MaxConnIdleTime = time.Duration(cfg.Pool.MaxIdleTime)
        poolConfig.HealthCheckPeriod = time.Duration(cfg.Pool.HealthCheckPeriod)

        pool, err := pgxpool.NewWithConfig(context.Background(), poolConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create connection pool: %w", err)
        }</span>

        <span class="cov0" title="0">var attempt int
        for attempt &lt; cfg.ConnectionAttempts </span><span class="cov0" title="0">{
                if err := pool.Ping(context.Background()); err == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">attempt++
                time.Sleep(time.Second * 2)
                log.Warnw("Attempt to connect to PostgreSQL",
                        "attempt", attempt,
                        "max_attempts", cfg.ConnectionAttempts,
                        "error", err,
                )</span>
        }

        <span class="cov0" title="0">if attempt == cfg.ConnectionAttempts </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to PostgreSQL after %d attempts", cfg.ConnectionAttempts)
        }</span>

        <span class="cov0" title="0">return pool, nil</span>
}

func (s *StorageConfig) GetDSN() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                s.Postgres.Hosts[0], s.Postgres.Port, s.Postgres.Username, s.Postgres.Password, s.Postgres.Database, s.Postgres.SSLMode,
        )
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package http

import (
        "avito-tech-merch/internal/models/dto"
        "avito-tech-merch/internal/service"
        "github.com/gin-gonic/gin"
        "net/http"
)

type authController struct {
        service service.Service
}

func NewAuthController(service service.Service) AuthController <span class="cov8" title="1">{
        return &amp;authController{service: service}
}</span>

// Register godoc
// @Summary Register a new user
// @Description Register a new user with username and password, returns a JWT token
// @Tags auth
// @Accept  json
// @Produce  json
// @Param request body dto.RegisterRequest true "User registration data"
// @Success 200 {object} dto.AuthResponse "JWT token"
// @Failure 400 {object} dto.ErrorResponse400 "Invalid request"
// @Failure 500 {object} dto.ErrorResponse500 "Internal server error"
// @Router /auth/register [post]
func (c *authController) Register(ctx *gin.Context) <span class="cov8" title="1">{
        var request struct {
                Username string `json:"username" binding:"required"`
                Password string `json:"password" binding:"required"`
        }

        if err := ctx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, dto.ErrorResponse400{Code: 400, Message: "invalid request"})
                return
        }</span>

        <span class="cov8" title="1">token, err := c.service.Register(ctx, request.Username, request.Password)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, dto.ErrorResponse500{Code: 500, Message: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, dto.AuthResponse{Token: token})</span>
}

// Login godoc
// @Summary Login a user
// @Description Login a user with username and password, returns a JWT token
// @Tags auth
// @Accept  json
// @Produce  json
// @Param request body dto.LoginRequest true "User login data"
// @Success 200 {object} dto.AuthResponse "JWT token"
// @Failure 400 {object} dto.ErrorResponse400 "Invalid request"
// @Failure 401 {object} dto.ErrorResponseInvalidCredentials401 "Invalid credentials"
// @Router /auth/login [post]
func (c *authController) Login(ctx *gin.Context) <span class="cov8" title="1">{
        var request struct {
                Username string `json:"username" binding:"required"`
                Password string `json:"password" binding:"required"`
        }

        if err := ctx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, dto.ErrorResponse400{Code: 400, Message: "invalid request"})
                return
        }</span>

        <span class="cov8" title="1">token, err := c.service.Login(ctx, request.Username, request.Password)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusUnauthorized, dto.ErrorResponseInvalidCredentials401{Code: 401, Message: "invalid credentials"})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, dto.AuthResponse{Token: token})</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package http

import (
        "github.com/gin-gonic/gin"
)

type Controller interface {
        AuthController
        UserController
        MerchController
        PurchaseController
        TransactionController
}

type AuthController interface {
        Register(ctx *gin.Context)
        Login(ctx *gin.Context)
}

type UserController interface {
        GetInfo(ctx *gin.Context)
}

type MerchController interface {
        ListMerch(ctx *gin.Context)
}

type PurchaseController interface {
        BuyMerch(ctx *gin.Context)
}

type TransactionController interface {
        SendCoin(ctx *gin.Context)
}

type controller struct {
        AuthController
        UserController
        MerchController
        PurchaseController
        TransactionController
}

func NewController(
        auth AuthController,
        user UserController,
        merch MerchController,
        purchase PurchaseController,
        transaction TransactionController,
) Controller <span class="cov0" title="0">{
        return &amp;controller{
                AuthController:        auth,
                UserController:        user,
                MerchController:       merch,
                PurchaseController:    purchase,
                TransactionController: transaction,
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package http

import (
        "avito-tech-merch/internal/models/dto"
        "avito-tech-merch/internal/service"
        "github.com/gin-gonic/gin"
        "net/http"
)

type merchController struct {
        service service.Service
}

func NewMerchController(service service.Service) MerchController <span class="cov8" title="1">{
        return &amp;merchController{service: service}
}</span>

// ListMerch godoc
// @Summary Get list of merchandise items
// @Security BearerAuth
// @Description Fetches all merch items from the database and returns a list of merch
// @Tags merch
// @Accept  json
// @Produce  json
// @Success 200 {array} dto.MerchDTO "List of merchandise items"
// @Failure 500 {object} dto.ErrorResponse500 "Internal server error"
// @Router /merch [get]
func (c *merchController) ListMerch(ctx *gin.Context) <span class="cov8" title="1">{
        merchList, err := c.service.ListMerch(ctx)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, dto.ErrorResponse500{Code: 500, Message: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">merchListDTO := make([]*dto.MerchDTO, len(merchList))
        for i, merch := range merchList </span><span class="cov8" title="1">{
                merchListDTO[i] = dto.MapMerchToDTO(merch)
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, merchListDTO)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "avito-tech-merch/internal/models/dto"
        "avito-tech-merch/internal/service"
        "github.com/gin-gonic/gin"
        "net/http"
        "strings"
)

func JWTAuthMiddleware(authService service.AuthService) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                token := c.GetHeader("Authorization")
                if token == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, dto.ErrorJWTMissingToken{
                                Code:    401,
                                Message: "missing token",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">token = strings.TrimPrefix(token, "Bearer ")

                userID, err := authService.ValidateToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, dto.ErrorJWTInvalidToken{
                                Code:    401,
                                Message: "invalid token",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Set("userID", userID)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package http

import (
        "avito-tech-merch/internal/models/dto"
        "avito-tech-merch/internal/service"
        "github.com/gin-gonic/gin"
        "net/http"
)

type purchaseController struct {
        service service.Service
}

func NewPurchaseController(service service.Service) PurchaseController <span class="cov8" title="1">{
        return &amp;purchaseController{service: service}
}</span>

// BuyMerch godoc
// @Summary Purchase a merchandise item
// @Security BearerAuth
// @Description Allows a user to purchase a merchandise item by specifying the item ID in the URL
// @Tags purchase
// @Accept  json
// @Produce  json
// @Param item path string true "Item ID to purchase" example:"cup"
// @Success 200 {object} dto.PurchaseSuccessResponse "Purchase successful"
// @Failure 400 {object} dto.ErrorResponse400 "Bad request (item is required)"
// @Failure 401 {object} dto.ErrorResponseUnauthorized401 "Unauthorized"
// @Failure 500 {object} dto.ErrorResponse500 "Internal server error"
// @Router /merch/buy/{item} [post]
func (c *purchaseController) BuyMerch(ctx *gin.Context) <span class="cov8" title="1">{
        userID, exists := ctx.Get("userID")
        if !exists </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusUnauthorized, dto.ErrorResponseUnauthorized401{Code: 401, Message: "unauthorized"})
                return
        }</span>

        <span class="cov8" title="1">item := ctx.Param("item")
        if item == "" </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, dto.ErrorResponse400{Code: 400, Message: "item is required"})
                return
        }</span>

        <span class="cov8" title="1">err := c.service.PurchaseMerch(ctx, userID.(int), item)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, dto.ErrorResponse500{Code: 500, Message: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, dto.PurchaseSuccessResponse{Message: "purchase successful"})</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package http

import (
        "avito-tech-merch/internal/models/dto"
        "avito-tech-merch/internal/service"
        "github.com/gin-gonic/gin"
        "net/http"
)

type transactionController struct {
        service service.Service
}

func NewTransactionController(service service.Service) TransactionController <span class="cov8" title="1">{
        return &amp;transactionController{service: service}
}</span>

// SendCoin godoc
// @Summary Transfer coins between users
// @Security BearerAuth
// @Description Allows a user to send coins to another user by specifying the receiver ID and the amount
// @Tags transaction
// @Accept  json
// @Produce  json
// @Param request body dto.TransferRequest true "Transfer request data"
// @Success 200 {object} dto.TransferSuccessResponse "Coins transferred successfully"
// @Failure 400 {object} dto.ErrorResponse400 "Invalid request (missing or invalid data)"
// @Failure 401 {object} dto.ErrorResponseUnauthorized401 "Unauthorized"
// @Failure 500 {object} dto.ErrorResponse500 "Internal server error"
// @Router /send-coin [post]
func (c *transactionController) SendCoin(ctx *gin.Context) <span class="cov8" title="1">{
        senderID, exists := ctx.Get("userID")
        if !exists </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusUnauthorized, dto.ErrorResponseUnauthorized401{Code: 401, Message: "unauthorized"})
                return
        }</span>

        <span class="cov8" title="1">var request struct {
                ReceiverID int `json:"receiver_id" binding:"required"`
                Amount     int `json:"amount" binding:"required"`
        }

        if err := ctx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, dto.ErrorResponse400{Code: 400, Message: "invalid request"})
                return
        }</span>

        <span class="cov8" title="1">err := c.service.TransferCoins(ctx, senderID.(int), request.ReceiverID, request.Amount)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, dto.ErrorResponse500{Code: 500, Message: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, dto.TransferSuccessResponse{Message: "coins transferred successfully"})</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package http

import (
        "avito-tech-merch/internal/models/dto"
        "avito-tech-merch/internal/service"
        "github.com/gin-gonic/gin"
        "net/http"
)

type userController struct {
        service service.Service
}

func NewUserController(service service.Service) UserController <span class="cov8" title="1">{
        return &amp;userController{service: service}
}</span>

// GetInfo godoc
// @Summary Get user information
// @Security BearerAuth
// @Description Fetches user information based on the userID from the context
// @Tags user
// @Accept  json
// @Produce  json
// @Success 200 {object} dto.UserInfoResponse "User information"
// @Failure 401 {object} dto.ErrorResponseUnauthorized401 "Unauthorized"
// @Failure 500 {object} dto.ErrorResponse500 "Internal server error"
// @Router /info [get]
func (c *userController) GetInfo(ctx *gin.Context) <span class="cov8" title="1">{
        userID, exists := ctx.Get("userID")
        if !exists </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusUnauthorized, dto.ErrorResponseUnauthorized401{Code: 401, Message: "unauthorized"})
                return
        }</span>

        <span class="cov8" title="1">info, err := c.service.GetInfo(ctx, userID.(int))
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, dto.ErrorResponse500{Code: 500, Message: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">infoDTO := dto.MapUserInfoResponseToDTO(info)

        ctx.JSON(http.StatusOK, infoDTO)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package metrics

import "github.com/prometheus/client_golang/prometheus"

var (
        // RegistrationsTotal - счетчик количества регистраций
        RegistrationsTotal = prometheus.NewCounter(
                prometheus.CounterOpts{
                        Name: "registrations_total",
                        Help: "Total number of user registrations.",
                },
        )

        // LoginsTotal - счетчик количества авторизаций
        LoginsTotal = prometheus.NewCounter(
                prometheus.CounterOpts{
                        Name: "logins_total",
                        Help: "Total number of user logins.",
                },
        )

        // CoinTransfersTotal - счетчик количества операций по передаче монет
        CoinTransfersTotal = prometheus.NewCounter(
                prometheus.CounterOpts{
                        Name: "coin_transfers_total",
                        Help: "Total number of coin transfers.",
                },
        )

        // MerchPurchasesTotal - счетчик количества покупок мерча
        MerchPurchasesTotal = prometheus.NewCounter(
                prometheus.CounterOpts{
                        Name: "merch_purchases_total",
                        Help: "Total number of merch purchases.",
                },
        )
)

func init() <span class="cov0" title="0">{
        prometheus.MustRegister(RegistrationsTotal, LoginsTotal, CoinTransfersTotal, MerchPurchasesTotal)
}</span>

func RecordRegistration() <span class="cov0" title="0">{
        RegistrationsTotal.Inc()
}</span>

func RecordLogin() <span class="cov0" title="0">{
        LoginsTotal.Inc()
}</span>

func RecordCoinTransfer() <span class="cov0" title="0">{
        CoinTransfersTotal.Inc()
}</span>

func RecordMerchPurchase() <span class="cov0" title="0">{
        MerchPurchasesTotal.Inc()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package metrics

import "github.com/prometheus/client_golang/prometheus"

var (
        // DBQueryDuration - гистограмма времени выполнения запросов к базе данных
        DBQueryDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "db_query_duration_seconds",
                        Help:    "Duration of database queries.",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"query"},
        )

        // DBActiveConnections - gauge для количества активных соединений с базой данных
        DBActiveConnections = prometheus.NewGauge(
                prometheus.GaugeOpts{
                        Name: "db_active_connections",
                        Help: "Number of active database connections.",
                },
        )

        // DBErrorsTotal - счетчик количества ошибок при выполнении запросов к базе данных
        DBErrorsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "db_errors_total",
                        Help: "Total number of database errors.",
                },
                []string{"query"},
        )
)

func init() <span class="cov0" title="0">{
        prometheus.MustRegister(DBQueryDuration, DBActiveConnections, DBErrorsTotal)
}</span>

func RecordDBQueryDuration(query string, duration float64) <span class="cov0" title="0">{
        DBQueryDuration.WithLabelValues(query).Observe(duration)
}</span>

func RecordDBActiveConnections(count int) <span class="cov0" title="0">{
        DBActiveConnections.Set(float64(count))
}</span>

func RecordDBError(query string) <span class="cov0" title="0">{
        DBErrorsTotal.WithLabelValues(query).Inc()
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package metrics

import (
        "github.com/gin-gonic/gin"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "net/http"
        "time"
)

var (
        // HTTPRequestsTotal - счетчик общего количества HTTP-запросов
        HTTPRequestsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "http_requests_total",
                        Help: "Total number of HTTP requests.",
                },
                []string{"method", "endpoint", "status"},
        )

        // HTTPRequestDuration - гистограмма времени выполнения HTTP-запросов
        HTTPRequestDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_requests_duration_seconds",
                        Help:    "Duration of HTTP requests.",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"method", "endpoint"},
        )

        // HTTPErrorsTotal - счетчик количества ошибок HTTP-запросов
        HTTPErrorsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "http_errors_total",
                        Help: "Total number of HTTP errors.",
                },
                []string{"method", "endpoint", "status"},
        )
)

func init() <span class="cov0" title="0">{
        prometheus.MustRegister(HTTPRequestsTotal, HTTPRequestDuration, HTTPErrorsTotal)
}</span>

func MetricsHandler() http.Handler <span class="cov0" title="0">{
        return promhttp.Handler()
}</span>

func GinPrometheusMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                c.Next()
                duration := time.Since(start).Seconds()
                status := c.Writer.Status()

                endpoint := c.FullPath()
                if endpoint == "" </span><span class="cov0" title="0">{
                        endpoint = c.Request.URL.Path
                }</span>

                <span class="cov0" title="0">HTTPRequestsTotal.WithLabelValues(c.Request.Method, endpoint, http.StatusText(status)).Inc()
                HTTPRequestDuration.WithLabelValues(c.Request.Method, endpoint).Observe(duration)
                if status &gt;= 400 </span><span class="cov0" title="0">{
                        HTTPErrorsTotal.WithLabelValues(c.Request.Method, endpoint, http.StatusText(status)).Inc()
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package dto

import "avito-tech-merch/internal/models"

// MerchDTO DTO for Merch data in API response
// @Description DTO representing merch information
type MerchDTO struct {
        ID    int    `json:"id" example:"2"`
        Name  string `json:"name" example:"cup"`
        Price int    `json:"price" example:"20"`
}

// MapMerchToDTO Maps Merch model to MerchDTO
func MapMerchToDTO(merch *models.Merch) *MerchDTO <span class="cov8" title="1">{
        return &amp;MerchDTO{
                ID:    merch.ID,
                Name:  merch.Name,
                Price: merch.Price,
        }
}</span>

// MapMerchDTOToMerch Maps MerchDTO to Merch model
func MapMerchDTOToMerch(merchDTO *MerchDTO) *models.Merch <span class="cov8" title="1">{
        return &amp;models.Merch{
                ID:    merchDTO.ID,
                Name:  merchDTO.Name,
                Price: merchDTO.Price,
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package dto

import (
        "avito-tech-merch/internal/models"
        "time"
)

// PurchaseDTO DTO for Purchase data in API response
// @Description DTO representing purchase information
type PurchaseDTO struct {
        ID        int       `json:"id" example:"1"`
        UserID    int       `json:"user_id" example:"1"`
        MerchID   int       `json:"merch_id" example:"3"`
        CreatedAt time.Time `json:"created_at" example:"2025-02-15T10:00:00"`
}

// PurchaseSuccessResponse DTO for successful purchase response
// @Description Response indicating that the purchase was successful
type PurchaseSuccessResponse struct {
        Message string `json:"message" example:"purchase successful"`
}

// MapPurchaseToDTO Maps Purchase model to PurchaseDTO
func MapPurchaseToDTO(purchase *models.Purchase) *PurchaseDTO <span class="cov8" title="1">{
        return &amp;PurchaseDTO{
                ID:        purchase.ID,
                UserID:    purchase.UserID,
                MerchID:   purchase.MerchID,
                CreatedAt: purchase.CreatedAt,
        }
}</span>

// MapPurchaseDTOToPurchase Maps PurchaseDTO to Purchase model
func MapPurchaseDTOToPurchase(purchaseDTO *PurchaseDTO) *models.Purchase <span class="cov8" title="1">{
        return &amp;models.Purchase{
                ID:        purchaseDTO.ID,
                UserID:    purchaseDTO.UserID,
                MerchID:   purchaseDTO.MerchID,
                CreatedAt: purchaseDTO.CreatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package dto

import (
        "avito-tech-merch/internal/models"
        "time"
)

// TransactionDTO DTO for Transaction data in API response
// @Description DTO representing transaction information
type TransactionDTO struct {
        ID         int       `json:"id" example:"1"`
        SenderID   int       `json:"sender_id" example:"1"`
        ReceiverID int       `json:"receiver_id" example:"2"`
        Amount     int       `json:"amount" example:"200"`
        CreatedAt  time.Time `json:"created_at" example:"2025-02-16T14:30:00"`
}

// TransferRequest DTO for transferring coins
// @Description Data for transferring coins between users
type TransferRequest struct {
        ReceiverID int `json:"receiver_id" binding:"required" example:"2"`
        Amount     int `json:"amount" binding:"required" example:"100"`
}

// TransferSuccessResponse DTO for successful coin transfer response
// @Description Response indicating that the coin transfer was successful
type TransferSuccessResponse struct {
        Message string `json:"message" example:"coins transferred successfully"`
}

// MapTransactionToDTO Maps Transaction model to TransactionDTO
func MapTransactionToDTO(transaction *models.Transaction) *TransactionDTO <span class="cov8" title="1">{
        return &amp;TransactionDTO{
                ID:         transaction.ID,
                SenderID:   transaction.SenderID,
                ReceiverID: transaction.ReceiverID,
                Amount:     transaction.Amount,
                CreatedAt:  transaction.CreatedAt,
        }
}</span>

// MapTransactionDTOToTransaction Maps TransactionDTO to Transaction model
func MapTransactionDTOToTransaction(transactionDTO *TransactionDTO) *models.Transaction <span class="cov8" title="1">{
        return &amp;models.Transaction{
                ID:         transactionDTO.ID,
                SenderID:   transactionDTO.SenderID,
                ReceiverID: transactionDTO.ReceiverID,
                Amount:     transactionDTO.Amount,
                CreatedAt:  transactionDTO.CreatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package dto

import (
        "avito-tech-merch/internal/models"
)

// UserInfoResponse User information response
// @Description Response containing user information
type UserInfoResponse struct {
        UserID       int               `json:"user_id" example:"1"`
        Username     string            `json:"username" example:"epchamp001"`
        Balance      int               `json:"balance" example:"1500"`
        Purchases    []*PurchaseDTO    `json:"purchases"`
        Transactions []*TransactionDTO `json:"transactions"`
}

// MapUserInfoResponseToDTO Maps internal UserInfo model to UserInfoResponse DTO
func MapUserInfoResponseToDTO(userInfo *models.UserInfo) *UserInfoResponse <span class="cov8" title="1">{
        purchasesDTO := make([]*PurchaseDTO, len(userInfo.Purchases))
        for i, purchase := range userInfo.Purchases </span><span class="cov8" title="1">{
                purchasesDTO[i] = MapPurchaseToDTO(purchase)
        }</span>

        <span class="cov8" title="1">transactionsDTO := make([]*TransactionDTO, len(userInfo.Transactions))
        for i, transaction := range userInfo.Transactions </span><span class="cov8" title="1">{
                transactionsDTO[i] = MapTransactionToDTO(transaction)
        }</span>

        <span class="cov8" title="1">return &amp;UserInfoResponse{
                UserID:       userInfo.UserID,
                Username:     userInfo.Username,
                Balance:      userInfo.Balance,
                Purchases:    purchasesDTO,
                Transactions: transactionsDTO,
        }</span>
}

func MapDTOToUserInfoResponse(userInfoDTO *UserInfoResponse) *models.UserInfo <span class="cov8" title="1">{
        purchases := make([]*models.Purchase, len(userInfoDTO.Purchases))
        for i, purchaseDTO := range userInfoDTO.Purchases </span><span class="cov8" title="1">{
                purchases[i] = MapPurchaseDTOToPurchase(purchaseDTO)
        }</span>

        <span class="cov8" title="1">transactions := make([]*models.Transaction, len(userInfoDTO.Transactions))
        for i, transactionDTO := range userInfoDTO.Transactions </span><span class="cov8" title="1">{
                transactions[i] = MapTransactionDTOToTransaction(transactionDTO)
        }</span>

        <span class="cov8" title="1">return &amp;models.UserInfo{
                UserID:       userInfoDTO.UserID,
                Username:     userInfoDTO.Username,
                Balance:      userInfoDTO.Balance,
                Purchases:    purchases,
                Transactions: transactions,
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package service

import (
        "avito-tech-merch/internal/config"
        "avito-tech-merch/internal/metrics"
        "avito-tech-merch/internal/models"
        "avito-tech-merch/internal/storage/db"
        "avito-tech-merch/internal/storage/db/postgres"
        myjwt "avito-tech-merch/pkg/jwt"
        "avito-tech-merch/pkg/logger"
        pass "avito-tech-merch/pkg/password"
        "context"
        "errors"
        "fmt"
        "github.com/golang-jwt/jwt/v5"
        "github.com/jackc/pgx/v5"
        "time"
)

type authService struct {
        repo         db.Repository
        logger       logger.Logger
        JWTConfig    config.JWTConfig
        tokenService myjwt.TokenService
        txManager    db.TxManager
}

func NewAuthService(repo db.Repository, log logger.Logger, jwtConfig config.JWTConfig, tokenService myjwt.TokenService, txManager db.TxManager) AuthService <span class="cov8" title="1">{
        return &amp;authService{
                repo:         repo,
                logger:       log,
                JWTConfig:    jwtConfig,
                tokenService: tokenService,
                txManager:    txManager,
        }
}</span>

func (s *authService) Register(ctx context.Context, username string, password string) (string, error) <span class="cov8" title="1">{
        metrics.RecordRegistration()

        var token string

        err := s.txManager.WithTx(ctx, postgres.IsolationLevelReadCommitted, postgres.AccessModeReadWrite, func(txCtx context.Context) error </span><span class="cov8" title="1">{
                existingUser, err := s.repo.GetUserByUsername(txCtx, username)
                if err != nil &amp;&amp; !errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                        s.logger.Errorw("Failed to get user by username",
                                "error", err,
                                "username", username,
                        )
                        return err
                }</span>

                <span class="cov8" title="1">if existingUser != nil </span><span class="cov8" title="1">{
                        s.logger.Infow("User already exists",
                                "username", username,
                        )
                        return fmt.Errorf("user already exists")
                }</span>

                <span class="cov8" title="1">hashedPassword, err := pass.HashPassword(password)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Errorw("Failed to hash password",
                                "error", err,
                                "username", username,
                        )
                        return err
                }</span>

                <span class="cov8" title="1">user := &amp;models.User{
                        Username:     username,
                        PasswordHash: hashedPassword,
                        Balance:      1000,
                        CreatedAt:    time.Now(),
                }

                userID, err := s.repo.CreateUser(txCtx, user)
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Errorw("Failed to create user",
                                "error", err,
                                "username", username,
                        )
                        return err
                }</span>

                <span class="cov8" title="1">token, err = s.tokenService.GenerateToken(userID, s.JWTConfig.SecretKey, s.JWTConfig.TokenExpiry)
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Errorw("Failed to generate token",
                                "error", err,
                                "userID", userID,
                        )
                        return fmt.Errorf("failed to generate token: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw("Error during Register operation",
                        "error", err,
                )
                return "", err
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}

func (s *authService) Login(ctx context.Context, username string, password string) (string, error) <span class="cov8" title="1">{
        metrics.RecordLogin()

        user, err := s.repo.GetUserByUsername(ctx, username)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                        s.logger.Infow("User not found",
                                "username", username,
                        )
                        return "", errors.New("user not found")
                }</span>
                <span class="cov8" title="1">s.logger.Errorw("Failed to get user by username",
                        "error", err,
                        "username", username,
                )
                return "", err</span>
        }

        <span class="cov8" title="1">if !pass.CheckPassword(user.PasswordHash, password) </span><span class="cov8" title="1">{
                s.logger.Infow("Invalid password",
                        "username", username,
                )
                return "", fmt.Errorf("invalid password")
        }</span>

        <span class="cov8" title="1">token, err := s.tokenService.GenerateToken(user.ID, s.JWTConfig.SecretKey, s.JWTConfig.TokenExpiry)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw("Failed to generate token",
                        "error", err,
                        "userID", user.ID,
                )
                return "", fmt.Errorf("failed to generate token: %w", err)
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}

func (s *authService) ValidateToken(token string) (int, error) <span class="cov8" title="1">{
        userID, err := s.tokenService.ParseJWTToken(token, s.JWTConfig.SecretKey)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, jwt.ErrSignatureInvalid) </span><span class="cov8" title="1">{
                        s.logger.Errorw("Invalid token signature",
                                "error", err,
                        )
                        return 0, fmt.Errorf("invalid token signature")
                }</span>
                <span class="cov8" title="1">s.logger.Errorw("Invalid token",
                        "error", err,
                )
                return 0, fmt.Errorf("invalid token")</span>
        }

        <span class="cov8" title="1">return userID, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package service

import (
        "avito-tech-merch/internal/models"
        "avito-tech-merch/internal/storage/db"
        "avito-tech-merch/pkg/logger"
        "context"
)

type merchService struct {
        repo   db.Repository
        logger logger.Logger
}

func NewMerchService(repo db.Repository, log logger.Logger) MerchService <span class="cov8" title="1">{
        return &amp;merchService{repo: repo, logger: log}
}</span>

func (s *merchService) ListMerch(ctx context.Context) ([]*models.Merch, error) <span class="cov8" title="1">{
        merchList, err := s.repo.GetAllMerch(ctx)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw("Failed to fetch merch list",
                        "error", err,
                )
                return nil, err
        }</span>

        <span class="cov8" title="1">return merchList, nil</span>
}

func (s *merchService) GetMerch(ctx context.Context, merchID int) (*models.Merch, error) <span class="cov8" title="1">{
        merch, err := s.repo.GetMerchByID(ctx, merchID)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw("Failed to fetch merch",
                        "merchID", merchID,
                        "error", err,
                )
                return nil, err
        }</span>

        <span class="cov8" title="1">return merch, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by mockery v2.53.0. DO NOT EDIT.

package mock

import (
        models "avito-tech-merch/internal/models"
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// Service is an autogenerated mock type for the Service type
type Service struct {
        mock.Mock
}

// GetInfo provides a mock function with given fields: ctx, userID
func (_m *Service) GetInfo(ctx context.Context, userID int) (*models.UserInfo, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, userID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetInfo")</span>
        }

        <span class="cov0" title="0">var r0 *models.UserInfo
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) (*models.UserInfo, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, userID)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, int) *models.UserInfo); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.UserInfo)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetMerch provides a mock function with given fields: ctx, merchID
func (_m *Service) GetMerch(ctx context.Context, merchID int) (*models.Merch, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, merchID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetMerch")</span>
        }

        <span class="cov0" title="0">var r0 *models.Merch
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) (*models.Merch, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, merchID)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, int) *models.Merch); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, merchID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.Merch)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, merchID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// ListMerch provides a mock function with given fields: ctx
func (_m *Service) ListMerch(ctx context.Context) ([]*models.Merch, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ListMerch")</span>
        }

        <span class="cov0" title="0">var r0 []*models.Merch
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) ([]*models.Merch, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context) []*models.Merch); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]*models.Merch)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Login provides a mock function with given fields: ctx, username, password
func (_m *Service) Login(ctx context.Context, username string, password string) (string, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, username, password)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Login")</span>
        }

        <span class="cov0" title="0">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, username, password)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, username, password)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, username, password)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// PurchaseMerch provides a mock function with given fields: ctx, userID, merchName
func (_m *Service) PurchaseMerch(ctx context.Context, userID int, merchName string) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, userID, merchName)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for PurchaseMerch")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, int, string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, userID, merchName)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// Register provides a mock function with given fields: ctx, username, password
func (_m *Service) Register(ctx context.Context, username string, password string) (string, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, username, password)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Register")</span>
        }

        <span class="cov0" title="0">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, username, password)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, username, password)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, username, password)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// TransferCoins provides a mock function with given fields: ctx, senderID, receiverID, amount
func (_m *Service) TransferCoins(ctx context.Context, senderID int, receiverID int, amount int) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, senderID, receiverID, amount)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for TransferCoins")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, int, int, int) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, senderID, receiverID, amount)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// ValidateToken provides a mock function with given fields: token
func (_m *Service) ValidateToken(token string) (int, error) <span class="cov0" title="0">{
        ret := _m.Called(token)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ValidateToken")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(token)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) int); ok </span><span class="cov0" title="0">{
                r0 = rf(token)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(token)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewService creates a new instance of Service. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewService(t interface {
        mock.TestingT
        Cleanup(func())
}) *Service <span class="cov0" title="0">{
        mock := &amp;Service{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package service

import (
        "avito-tech-merch/internal/metrics"
        "avito-tech-merch/internal/models"
        "avito-tech-merch/internal/storage/db"
        "avito-tech-merch/internal/storage/db/postgres"
        "avito-tech-merch/pkg/logger"
        "context"
        "fmt"
        "time"
)

type purchaseService struct {
        repo      db.Repository
        logger    logger.Logger
        txManager db.TxManager
}

func NewPurchaseService(repo db.Repository, log logger.Logger, txManager db.TxManager) *purchaseService <span class="cov8" title="1">{
        return &amp;purchaseService{repo: repo, logger: log, txManager: txManager}
}</span>

func (s *purchaseService) PurchaseMerch(ctx context.Context, userID int, merchName string) error <span class="cov8" title="1">{
        metrics.RecordMerchPurchase()
        var err error

        merch, err := s.repo.GetMerchByName(ctx, merchName)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw("Failed to get merch",
                        "merchName", merchName,
                        "error", err,
                )
                return fmt.Errorf("failed to get merch: %w", err)
        }</span>

        <span class="cov8" title="1">const maxRetries = 3

        for attempt := 1; attempt &lt;= maxRetries; attempt++ </span><span class="cov8" title="1">{
                err = s.txManager.WithTx(ctx, postgres.IsolationLevelSerializable, postgres.AccessModeReadWrite, func(txCtx context.Context) error </span><span class="cov8" title="1">{
                        balance, err := s.repo.GetBalanceByID(txCtx, userID)
                        if err != nil </span><span class="cov8" title="1">{
                                s.logger.Errorw("Failed to get user balance",
                                        "userID", userID,
                                        "error", err,
                                )
                                return fmt.Errorf("failed to get user balance: %w", err)
                        }</span>

                        <span class="cov8" title="1">if balance &lt; merch.Price </span><span class="cov8" title="1">{
                                s.logger.Warnw("Insufficient funds",
                                        "userID", userID,
                                        "balance", balance,
                                        "merchPrice", merch.Price,
                                )
                                return fmt.Errorf("insufficient funds")
                        }</span>

                        <span class="cov8" title="1">newBalance := balance - merch.Price
                        if err = s.repo.UpdateBalance(txCtx, userID, newBalance); err != nil </span><span class="cov8" title="1">{
                                s.logger.Errorw("Failed to update user balance",
                                        "userID", userID,
                                        "newBalance", newBalance,
                                        "error", err,
                                )
                                return fmt.Errorf("failed to update user balance: %w", err)
                        }</span>

                        <span class="cov8" title="1">purchase := &amp;models.Purchase{
                                UserID:    userID,
                                MerchID:   merch.ID,
                                CreatedAt: time.Now(),
                        }

                        if _, err = s.repo.CreatePurchase(txCtx, purchase); err != nil </span><span class="cov8" title="1">{
                                s.logger.Errorw("Failed to create purchase",
                                        "userID", userID,
                                        "merchName", merchName,
                                        "error", err,
                                )
                                return fmt.Errorf("failed to create purchase: %w", err)
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                })

                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">if !IsSerializationError(err) </span><span class="cov8" title="1">{
                        s.logger.Errorw("Non-retryable error during PurchaseMerch", "error", err)
                        return err
                }</span>

                <span class="cov0" title="0">if attempt == maxRetries </span><span class="cov0" title="0">{
                        s.logger.Errorw("Failed to purchase merch after retries", "error", err)
                        return err
                }</span>

                <span class="cov0" title="0">s.logger.Infow("Serialization error during PurchaseMerch, retrying", "attempt", attempt, "error", err)
                time.Sleep(time.Duration(attempt) * 100 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package service

import (
        "avito-tech-merch/internal/models"
        "context"
)

type Service interface {
        AuthService
        UserService
        MerchService
        PurchaseService
        TransactionService
}

type AuthService interface {
        Register(ctx context.Context, username string, password string) (string, error)
        Login(ctx context.Context, username string, password string) (string, error)
        ValidateToken(token string) (int, error)
}

type UserService interface {
        GetInfo(ctx context.Context, userID int) (*models.UserInfo, error)
}

type MerchService interface {
        ListMerch(ctx context.Context) ([]*models.Merch, error)
        GetMerch(ctx context.Context, merchID int) (*models.Merch, error)
}

type PurchaseService interface {
        PurchaseMerch(ctx context.Context, userID int, merchName string) error
}

type TransactionService interface {
        TransferCoins(ctx context.Context, senderID int, receiverID int, amount int) error
}

type service struct {
        AuthService
        UserService
        MerchService
        PurchaseService
        TransactionService
}

func NewService(
        auth AuthService,
        user UserService,
        merch MerchService,
        purchase PurchaseService,
        transaction TransactionService,
) Service <span class="cov0" title="0">{
        return &amp;service{
                AuthService:        auth,
                UserService:        user,
                MerchService:       merch,
                PurchaseService:    purchase,
                TransactionService: transaction,
        }
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package service

import (
        "avito-tech-merch/internal/metrics"
        "avito-tech-merch/internal/models"
        "avito-tech-merch/internal/storage/db"
        "avito-tech-merch/internal/storage/db/postgres"
        "avito-tech-merch/pkg/logger"
        "context"
        "fmt"
        "strings"
        "time"
)

type transactionService struct {
        repo      db.Repository
        logger    logger.Logger
        txManager db.TxManager
}

func NewTransactionService(repo db.Repository, log logger.Logger, txManager db.TxManager) TransactionService <span class="cov8" title="1">{
        return &amp;transactionService{repo: repo, logger: log, txManager: txManager}
}</span>

func (s *transactionService) TransferCoins(ctx context.Context, senderID int, receiverID int, amount int) error <span class="cov8" title="1">{
        metrics.RecordCoinTransfer()

        if amount &lt;= 0 </span><span class="cov8" title="1">{
                s.logger.Warnw("Invalid transfer amount",
                        "senderID", senderID,
                        "receiverID", receiverID,
                        "amount", amount,
                )
                return fmt.Errorf("invalid transfer amount: amount must be positive")
        }</span>

        <span class="cov8" title="1">if senderID == receiverID </span><span class="cov8" title="1">{
                s.logger.Warnw("Sender and receiver are the same",
                        "senderID", senderID,
                        "receiverID", receiverID,
                )
                return fmt.Errorf("cannot transfer to yourself")
        }</span>

        <span class="cov8" title="1">const maxRetries = 3
        var err error

        for attempt := 1; attempt &lt;= maxRetries; attempt++ </span><span class="cov8" title="1">{
                err = s.txManager.WithTx(ctx, postgres.IsolationLevelSerializable, postgres.AccessModeReadWrite, func(txCtx context.Context) error </span><span class="cov8" title="1">{
                        senderBalance, err := s.repo.GetBalanceByID(txCtx, senderID)
                        if err != nil </span><span class="cov8" title="1">{
                                s.logger.Errorw("Failed to get sender balance",
                                        "senderID", senderID,
                                        "error", err,
                                )
                                return fmt.Errorf("failed to get sender balance: %w", err)
                        }</span>

                        <span class="cov8" title="1">if senderBalance &lt; amount </span><span class="cov8" title="1">{
                                s.logger.Warnw("Insufficient funds",
                                        "senderID", senderID,
                                        "balance", senderBalance,
                                        "amount", amount,
                                )
                                return fmt.Errorf("insufficient funds")
                        }</span>

                        <span class="cov8" title="1">receiverBalance, err := s.repo.GetBalanceByID(txCtx, receiverID)
                        if err != nil </span><span class="cov8" title="1">{
                                s.logger.Errorw("Failed to get receiver balance",
                                        "receiverID", receiverID,
                                        "error", err,
                                )
                                return fmt.Errorf("failed to get receiver balance: %w", err)
                        }</span>

                        <span class="cov8" title="1">newSenderBalance := senderBalance - amount
                        if err = s.repo.UpdateBalance(txCtx, senderID, newSenderBalance); err != nil </span><span class="cov8" title="1">{
                                s.logger.Errorw("Failed to update sender balance",
                                        "senderID", senderID,
                                        "newBalance", newSenderBalance,
                                        "error", err,
                                )
                                return fmt.Errorf("failed to update sender balance: %w", err)
                        }</span>

                        <span class="cov8" title="1">newReceiverBalance := receiverBalance + amount
                        if err = s.repo.UpdateBalance(txCtx, receiverID, newReceiverBalance); err != nil </span><span class="cov8" title="1">{
                                s.logger.Errorw("Failed to update receiver balance",
                                        "receiverID", receiverID,
                                        "newBalance", newReceiverBalance,
                                        "error", err,
                                )
                                return fmt.Errorf("failed to update receiver balance: %w", err)
                        }</span>

                        <span class="cov8" title="1">transaction := &amp;models.Transaction{
                                SenderID:   senderID,
                                ReceiverID: receiverID,
                                Amount:     amount,
                                CreatedAt:  time.Now(),
                        }

                        if _, err = s.repo.CreateTransaction(txCtx, transaction); err != nil </span><span class="cov8" title="1">{
                                s.logger.Errorw("Failed to create transaction",
                                        "senderID", senderID,
                                        "receiverID", receiverID,
                                        "amount", amount,
                                        "error", err,
                                )
                                return fmt.Errorf("failed to create transaction: %w", err)
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                })

                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">if !IsSerializationError(err) </span><span class="cov8" title="1">{
                        s.logger.Errorw("Non-retryable error during TransferCoins", "error", err)
                        return err
                }</span>

                <span class="cov0" title="0">if attempt == maxRetries </span><span class="cov0" title="0">{
                        s.logger.Errorw("Failed to transfer coins after retries", "error", err)
                        return err
                }</span>

                <span class="cov0" title="0">s.logger.Infow("Serialization error during coin transfer, retrying", "attempt", attempt, "error", err)
                time.Sleep(time.Duration(attempt) * 100 * time.Millisecond)</span> // Экспоненциальная задержка: 100ms, 200ms, 300ms

        }
        <span class="cov0" title="0">return err</span>
}

func IsSerializationError(err error) bool <span class="cov8" title="1">{
        return err != nil &amp;&amp; strings.Contains(err.Error(), "SQLSTATE 40001")
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package service

import (
        "avito-tech-merch/internal/models"
        "avito-tech-merch/internal/storage/db"
        "avito-tech-merch/internal/storage/db/postgres"
        "avito-tech-merch/pkg/logger"
        "context"
)

type userService struct {
        repo      db.Repository
        logger    logger.Logger
        txManager db.TxManager
}

func NewUserService(repo db.Repository, log logger.Logger, txManager db.TxManager) UserService <span class="cov8" title="1">{
        return &amp;userService{repo: repo, logger: log, txManager: txManager}
}</span>

func (s *userService) GetInfo(ctx context.Context, userID int) (*models.UserInfo, error) <span class="cov8" title="1">{
        var result *models.UserInfo

        err := s.txManager.WithTx(ctx, postgres.IsolationLevelReadCommitted, postgres.AccessModeReadOnly, func(txCtx context.Context) error </span><span class="cov8" title="1">{
                user, err := s.repo.GetUserByID(txCtx, userID)
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Errorw("Failed to get user info",
                                "userID", userID,
                                "error", err,
                        )
                        return err
                }</span>

                <span class="cov8" title="1">purchases, err := s.repo.GetPurchaseByUserID(txCtx, userID)
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Errorw("Failed to get purchases",
                                "userID", userID,
                                "error", err,
                        )
                        return err
                }</span>

                <span class="cov8" title="1">transactions, err := s.repo.GetTransactionByUserID(txCtx, userID)
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Errorw("Failed to get transactions",
                                "userID", userID,
                                "error", err,
                        )
                        return err
                }</span>

                <span class="cov8" title="1">result = &amp;models.UserInfo{
                        UserID:       user.ID,
                        Username:     user.Username,
                        Balance:      user.Balance,
                        Purchases:    purchases,
                        Transactions: transactions,
                }
                return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorw("Error getting user info",
                        "error", err,
                )
                return nil, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by mockery v2.53.0. DO NOT EDIT.

package mock

import (
        context "context"

        mock "github.com/stretchr/testify/mock"

        pgconn "github.com/jackc/pgx/v5/pgconn"

        pgx "github.com/jackc/pgx/v5"
)

// Executor is an autogenerated mock type for the Executor type
type Executor struct {
        mock.Mock
}

// Exec provides a mock function with given fields: ctx, sql, arguments
func (_m *Executor) Exec(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, sql)
        _ca = append(_ca, arguments...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Exec")</span>
        }

        <span class="cov0" title="0">var r0 pgconn.CommandTag
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (pgconn.CommandTag, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, sql, arguments...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) pgconn.CommandTag); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, sql, arguments...)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(pgconn.CommandTag)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, sql, arguments...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Query provides a mock function with given fields: ctx, sql, args
func (_m *Executor) Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, sql)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Query")</span>
        }

        <span class="cov0" title="0">var r0 pgx.Rows
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (pgx.Rows, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, sql, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) pgx.Rows); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, sql, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(pgx.Rows)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, sql, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// QueryRow provides a mock function with given fields: ctx, sql, args
func (_m *Executor) QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, sql)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryRow")</span>
        }

        <span class="cov0" title="0">var r0 pgx.Row
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) pgx.Row); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, sql, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(pgx.Row)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// NewExecutor creates a new instance of Executor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewExecutor(t interface {
        mock.TestingT
        Cleanup(func())
}) *Executor <span class="cov0" title="0">{
        mock := &amp;Executor{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by mockery v2.53.0. DO NOT EDIT.

package mock

import (
        context "context"

        mock "github.com/stretchr/testify/mock"

        models "avito-tech-merch/internal/models"
)

// MerchRepository is an autogenerated mock type for the MerchRepository type
type MerchRepository struct {
        mock.Mock
}

// GetAllMerch provides a mock function with given fields: ctx
func (_m *MerchRepository) GetAllMerch(ctx context.Context) ([]*models.Merch, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAllMerch")</span>
        }

        <span class="cov0" title="0">var r0 []*models.Merch
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) ([]*models.Merch, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context) []*models.Merch); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]*models.Merch)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetMerchByID provides a mock function with given fields: ctx, id
func (_m *MerchRepository) GetMerchByID(ctx context.Context, id int) (*models.Merch, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetMerchByID")</span>
        }

        <span class="cov0" title="0">var r0 *models.Merch
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) (*models.Merch, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, int) *models.Merch); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.Merch)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetMerchByName provides a mock function with given fields: ctx, merchName
func (_m *MerchRepository) GetMerchByName(ctx context.Context, merchName string) (*models.Merch, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, merchName)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetMerchByName")</span>
        }

        <span class="cov0" title="0">var r0 *models.Merch
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*models.Merch, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, merchName)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string) *models.Merch); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, merchName)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.Merch)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, merchName)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewMerchRepository creates a new instance of MerchRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMerchRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MerchRepository <span class="cov0" title="0">{
        mock := &amp;MerchRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by mockery v2.53.0. DO NOT EDIT.

package mock

import (
        context "context"

        mock "github.com/stretchr/testify/mock"

        models "avito-tech-merch/internal/models"
)

// PurchaseRepository is an autogenerated mock type for the PurchaseRepository type
type PurchaseRepository struct {
        mock.Mock
}

// CreatePurchase provides a mock function with given fields: ctx, purchase
func (_m *PurchaseRepository) CreatePurchase(ctx context.Context, purchase *models.Purchase) (int, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, purchase)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreatePurchase")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.Purchase) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, purchase)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *models.Purchase) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, purchase)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *models.Purchase) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, purchase)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetPurchaseByUserID provides a mock function with given fields: ctx, userID
func (_m *PurchaseRepository) GetPurchaseByUserID(ctx context.Context, userID int) ([]*models.Purchase, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, userID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetPurchaseByUserID")</span>
        }

        <span class="cov0" title="0">var r0 []*models.Purchase
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) ([]*models.Purchase, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, userID)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, int) []*models.Purchase); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]*models.Purchase)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewPurchaseRepository creates a new instance of PurchaseRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPurchaseRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *PurchaseRepository <span class="cov0" title="0">{
        mock := &amp;PurchaseRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by mockery v2.53.0. DO NOT EDIT.

package mock

import (
        context "context"

        mock "github.com/stretchr/testify/mock"

        models "avito-tech-merch/internal/models"
)

// Repository is an autogenerated mock type for the Repository type
type Repository struct {
        mock.Mock
}

// CreatePurchase provides a mock function with given fields: ctx, purchase
func (_m *Repository) CreatePurchase(ctx context.Context, purchase *models.Purchase) (int, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, purchase)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreatePurchase")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.Purchase) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, purchase)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *models.Purchase) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, purchase)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *models.Purchase) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, purchase)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// CreateTransaction provides a mock function with given fields: ctx, transaction
func (_m *Repository) CreateTransaction(ctx context.Context, transaction *models.Transaction) (int, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, transaction)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateTransaction")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.Transaction) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, transaction)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *models.Transaction) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, transaction)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *models.Transaction) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, transaction)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// CreateUser provides a mock function with given fields: ctx, user
func (_m *Repository) CreateUser(ctx context.Context, user *models.User) (int, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, user)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateUser")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.User) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, user)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *models.User) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, user)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *models.User) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, user)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetAllMerch provides a mock function with given fields: ctx
func (_m *Repository) GetAllMerch(ctx context.Context) ([]*models.Merch, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAllMerch")</span>
        }

        <span class="cov0" title="0">var r0 []*models.Merch
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) ([]*models.Merch, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context) []*models.Merch); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]*models.Merch)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetAllUsers provides a mock function with given fields: ctx
func (_m *Repository) GetAllUsers(ctx context.Context) ([]*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAllUsers")</span>
        }

        <span class="cov0" title="0">var r0 []*models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) ([]*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context) []*models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetBalanceByID provides a mock function with given fields: ctx, userID
func (_m *Repository) GetBalanceByID(ctx context.Context, userID int) (int, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, userID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBalanceByID")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, userID)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, int) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetBalanceByName provides a mock function with given fields: ctx, username
func (_m *Repository) GetBalanceByName(ctx context.Context, username string) (int, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, username)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBalanceByName")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, username)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, username)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, username)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetMerchByID provides a mock function with given fields: ctx, id
func (_m *Repository) GetMerchByID(ctx context.Context, id int) (*models.Merch, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetMerchByID")</span>
        }

        <span class="cov0" title="0">var r0 *models.Merch
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) (*models.Merch, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, int) *models.Merch); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.Merch)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetMerchByName provides a mock function with given fields: ctx, merchName
func (_m *Repository) GetMerchByName(ctx context.Context, merchName string) (*models.Merch, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, merchName)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetMerchByName")</span>
        }

        <span class="cov0" title="0">var r0 *models.Merch
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*models.Merch, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, merchName)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string) *models.Merch); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, merchName)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.Merch)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, merchName)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetPurchaseByUserID provides a mock function with given fields: ctx, userID
func (_m *Repository) GetPurchaseByUserID(ctx context.Context, userID int) ([]*models.Purchase, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, userID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetPurchaseByUserID")</span>
        }

        <span class="cov0" title="0">var r0 []*models.Purchase
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) ([]*models.Purchase, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, userID)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, int) []*models.Purchase); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]*models.Purchase)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetTransactionByUserID provides a mock function with given fields: ctx, userID
func (_m *Repository) GetTransactionByUserID(ctx context.Context, userID int) ([]*models.Transaction, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, userID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetTransactionByUserID")</span>
        }

        <span class="cov0" title="0">var r0 []*models.Transaction
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) ([]*models.Transaction, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, userID)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, int) []*models.Transaction); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]*models.Transaction)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetUserByID provides a mock function with given fields: ctx, userID
func (_m *Repository) GetUserByID(ctx context.Context, userID int) (*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, userID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUserByID")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, userID)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, int) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetUserByUsername provides a mock function with given fields: ctx, username
func (_m *Repository) GetUserByUsername(ctx context.Context, username string) (*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, username)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUserByUsername")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, username)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, username)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, username)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// UpdateBalance provides a mock function with given fields: ctx, userID, newBalance
func (_m *Repository) UpdateBalance(ctx context.Context, userID int, newBalance int) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, userID, newBalance)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateBalance")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, int, int) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, userID, newBalance)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// UpdateUser provides a mock function with given fields: ctx, user
func (_m *Repository) UpdateUser(ctx context.Context, user *models.User) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, user)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateUser")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.User) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, user)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewRepository creates a new instance of Repository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *Repository <span class="cov0" title="0">{
        mock := &amp;Repository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Code generated by mockery v2.53.0. DO NOT EDIT.

package mock

import (
        context "context"

        mock "github.com/stretchr/testify/mock"

        models "avito-tech-merch/internal/models"
)

// TransactionRepository is an autogenerated mock type for the TransactionRepository type
type TransactionRepository struct {
        mock.Mock
}

// CreateTransaction provides a mock function with given fields: ctx, transaction
func (_m *TransactionRepository) CreateTransaction(ctx context.Context, transaction *models.Transaction) (int, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, transaction)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateTransaction")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.Transaction) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, transaction)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *models.Transaction) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, transaction)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *models.Transaction) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, transaction)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetTransactionByUserID provides a mock function with given fields: ctx, userID
func (_m *TransactionRepository) GetTransactionByUserID(ctx context.Context, userID int) ([]*models.Transaction, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, userID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetTransactionByUserID")</span>
        }

        <span class="cov0" title="0">var r0 []*models.Transaction
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) ([]*models.Transaction, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, userID)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, int) []*models.Transaction); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]*models.Transaction)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewTransactionRepository creates a new instance of TransactionRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTransactionRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *TransactionRepository <span class="cov0" title="0">{
        mock := &amp;TransactionRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Code generated by mockery v2.53.0. DO NOT EDIT.

package mock

import (
        db "avito-tech-merch/internal/storage/db"
        context "context"

        mock "github.com/stretchr/testify/mock"

        pgx "github.com/jackc/pgx/v5"
)

// TxManager is an autogenerated mock type for the TxManager type
type TxManager struct {
        mock.Mock
}

// GetExecutor provides a mock function with given fields: ctx
func (_m *TxManager) GetExecutor(ctx context.Context) db.Executor <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetExecutor")</span>
        }

        <span class="cov0" title="0">var r0 db.Executor
        if rf, ok := ret.Get(0).(func(context.Context) db.Executor); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(db.Executor)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// WithTx provides a mock function with given fields: ctx, isoLevel, accessMode, fn
func (_m *TxManager) WithTx(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(context.Context) error) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, isoLevel, accessMode, fn)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WithTx")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, pgx.TxIsoLevel, pgx.TxAccessMode, func(context.Context) error) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, isoLevel, accessMode, fn)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewTxManager creates a new instance of TxManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTxManager(t interface {
        mock.TestingT
        Cleanup(func())
}) *TxManager <span class="cov0" title="0">{
        mock := &amp;TxManager{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Code generated by mockery v2.53.0. DO NOT EDIT.

package mock

import (
        context "context"

        mock "github.com/stretchr/testify/mock"

        models "avito-tech-merch/internal/models"
)

// UserRepository is an autogenerated mock type for the UserRepository type
type UserRepository struct {
        mock.Mock
}

// CreateUser provides a mock function with given fields: ctx, user
func (_m *UserRepository) CreateUser(ctx context.Context, user *models.User) (int, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, user)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateUser")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.User) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, user)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *models.User) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, user)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *models.User) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, user)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetAllUsers provides a mock function with given fields: ctx
func (_m *UserRepository) GetAllUsers(ctx context.Context) ([]*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAllUsers")</span>
        }

        <span class="cov0" title="0">var r0 []*models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) ([]*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context) []*models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetBalanceByID provides a mock function with given fields: ctx, userID
func (_m *UserRepository) GetBalanceByID(ctx context.Context, userID int) (int, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, userID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBalanceByID")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, userID)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, int) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetBalanceByName provides a mock function with given fields: ctx, username
func (_m *UserRepository) GetBalanceByName(ctx context.Context, username string) (int, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, username)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBalanceByName")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, username)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, username)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, username)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetUserByID provides a mock function with given fields: ctx, userID
func (_m *UserRepository) GetUserByID(ctx context.Context, userID int) (*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, userID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUserByID")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, userID)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, int) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetUserByUsername provides a mock function with given fields: ctx, username
func (_m *UserRepository) GetUserByUsername(ctx context.Context, username string) (*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, username)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUserByUsername")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, username)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, username)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, username)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// UpdateBalance provides a mock function with given fields: ctx, userID, newBalance
func (_m *UserRepository) UpdateBalance(ctx context.Context, userID int, newBalance int) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, userID, newBalance)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateBalance")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, int, int) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, userID, newBalance)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// UpdateUser provides a mock function with given fields: ctx, user
func (_m *UserRepository) UpdateUser(ctx context.Context, user *models.User) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, user)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateUser")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.User) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, user)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewUserRepository creates a new instance of UserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUserRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *UserRepository <span class="cov0" title="0">{
        mock := &amp;UserRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package postgres

import (
        "avito-tech-merch/internal/metrics"
        "avito-tech-merch/internal/models"
        "avito-tech-merch/internal/storage/db"
        "avito-tech-merch/pkg/logger"
        "context"
        "fmt"
        "time"
)

type postgresMerchRepository struct {
        conn   db.TxManager
        logger logger.Logger
}

func NewMerchRepository(conn db.TxManager, log logger.Logger) db.MerchRepository <span class="cov0" title="0">{
        return &amp;postgresMerchRepository{conn: conn, logger: log}
}</span>

func (r *postgresMerchRepository) GetAllMerch(ctx context.Context) ([]*models.Merch, error) <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                metrics.RecordDBQueryDuration("GetAllMerch", time.Since(start).Seconds())
        }</span>()

        <span class="cov0" title="0">pool := r.conn.GetExecutor(ctx)

        query := `
                SELECT id, name, price 
                FROM merch
        `

        rows, err := pool.Query(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error retrieving merch list",
                        "error", err,
                )
                metrics.RecordDBError("GetAllMerch")
                return nil, fmt.Errorf("failed to retrieve merch list: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var merchList []*models.Merch
        for rows.Next() </span><span class="cov0" title="0">{
                var merch models.Merch
                err := rows.Scan(
                        &amp;merch.ID,
                        &amp;merch.Name,
                        &amp;merch.Price,
                )
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Errorw("Error scanning merch data",
                                "error", err,
                        )
                        metrics.RecordDBError("GetAllMerch")
                        return nil, fmt.Errorf("error reading merch data: %w", err)
                }</span>
                <span class="cov0" title="0">merchList = append(merchList, &amp;merch)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error processing query result",
                        "error", err,
                )
                metrics.RecordDBError("GetAllMerch")
                return nil, fmt.Errorf("error processing query result: %w", err)
        }</span>

        <span class="cov0" title="0">return merchList, nil</span>
}

func (r *postgresMerchRepository) GetMerchByID(ctx context.Context, id int) (*models.Merch, error) <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                metrics.RecordDBQueryDuration("GetMerchByID", time.Since(start).Seconds())
        }</span>()

        <span class="cov0" title="0">pool := r.conn.GetExecutor(ctx)

        query := `
                SELECT id, name, price 
                FROM merch
                WHERE id = $1
        `

        var merch models.Merch
        err := pool.QueryRow(ctx, query, id).Scan(&amp;merch.ID, &amp;merch.Name, &amp;merch.Price)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error retrieving merch by ID",
                        "error", err,
                        "merchID", id,
                )
                metrics.RecordDBError("GetMerchByID")
                return nil, fmt.Errorf("failed to retrieve merch: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;merch, nil</span>
}

func (r *postgresMerchRepository) GetMerchByName(ctx context.Context, merchName string) (*models.Merch, error) <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                metrics.RecordDBQueryDuration("GetMerchByName", time.Since(start).Seconds())
        }</span>()

        <span class="cov0" title="0">pool := r.conn.GetExecutor(ctx)

        query := `
        SELECT id, name, price
        FROM merch
        WHERE name = $1
    `

        var merch models.Merch
        err := pool.QueryRow(ctx, query, merchName).Scan(
                &amp;merch.ID,
                &amp;merch.Name,
                &amp;merch.Price,
        )
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error retrieving merchandise by name",
                        "error", err,
                        "merchName", merchName,
                )
                metrics.RecordDBError("GetMerchByName")
                return nil, fmt.Errorf("failed to retrieve merchandise: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;merch, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package postgres

import (
        "avito-tech-merch/internal/metrics"
        "avito-tech-merch/internal/models"
        "avito-tech-merch/internal/storage/db"
        "avito-tech-merch/pkg/logger"
        "context"
        "fmt"
        "time"
)

type postgresPurchaseRepository struct {
        conn   db.TxManager
        logger logger.Logger
}

func NewPurchaseRepository(conn db.TxManager, log logger.Logger) db.PurchaseRepository <span class="cov0" title="0">{
        return &amp;postgresPurchaseRepository{conn: conn, logger: log}
}</span>

func (r *postgresPurchaseRepository) CreatePurchase(ctx context.Context, purchase *models.Purchase) (int, error) <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                metrics.RecordDBQueryDuration("CreatePurchase", time.Since(start).Seconds())
        }</span>()

        <span class="cov0" title="0">pool := r.conn.GetExecutor(ctx)

        query := `
        INSERT INTO purchases (user_id, merch_id)
        VALUES ($1, $2)
        RETURNING id
    `

        var purchaseID int
        err := pool.QueryRow(ctx, query, purchase.UserID, purchase.MerchID).Scan(&amp;purchaseID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error creating purchase",
                        "error", err,
                        "userID", purchase.UserID,
                        "merchID", purchase.MerchID,
                )
                metrics.RecordDBError("CreatePurchase")
                return 0, fmt.Errorf("failed to create purchase: %w", err)
        }</span>

        <span class="cov0" title="0">return purchaseID, nil</span>
}

func (r *postgresPurchaseRepository) GetPurchaseByUserID(ctx context.Context, userID int) ([]*models.Purchase, error) <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                metrics.RecordDBQueryDuration("GetPurchaseByUserID", time.Since(start).Seconds())
        }</span>()

        <span class="cov0" title="0">pool := r.conn.GetExecutor(ctx)

        query := `
        SELECT id, user_id, merch_id, created_at
        FROM purchases
        WHERE user_id = $1
    `

        rows, err := pool.Query(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error retrieving purchase list",
                        "error", err,
                        "userID", userID,
                )
                metrics.RecordDBError("GetPurchaseByUserID")
                return nil, fmt.Errorf("failed to retrieve purchase list: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var purchases []*models.Purchase
        for rows.Next() </span><span class="cov0" title="0">{
                var purchase models.Purchase
                err := rows.Scan(
                        &amp;purchase.ID,
                        &amp;purchase.UserID,
                        &amp;purchase.MerchID,
                        &amp;purchase.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Errorw("Error scanning purchase data",
                                "error", err,
                        )
                        metrics.RecordDBError("GetPurchaseByUserID")
                        return nil, fmt.Errorf("error reading purchase data: %w", err)
                }</span>
                <span class="cov0" title="0">purchases = append(purchases, &amp;purchase)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error processing query result",
                        "error", err,
                )
                metrics.RecordDBError("GetPurchaseByUserID")
                return nil, fmt.Errorf("error processing query result: %w", err)
        }</span>

        <span class="cov0" title="0">return purchases, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package postgres

import (
        "avito-tech-merch/internal/metrics"
        "avito-tech-merch/internal/models"
        "avito-tech-merch/internal/storage/db"
        "avito-tech-merch/pkg/logger"
        "context"
        "fmt"
        "time"
)

type postgresTransactionRepository struct {
        conn   db.TxManager
        logger logger.Logger
}

func NewTransactionRepository(conn db.TxManager, log logger.Logger) db.TransactionRepository <span class="cov0" title="0">{
        return &amp;postgresTransactionRepository{conn: conn, logger: log}
}</span>

func (r *postgresTransactionRepository) CreateTransaction(ctx context.Context, transaction *models.Transaction) (int, error) <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                metrics.RecordDBQueryDuration("CreateTransaction", time.Since(start).Seconds())
        }</span>()

        <span class="cov0" title="0">pool := r.conn.GetExecutor(ctx)

        query := `
        INSERT INTO transactions (sender_id, receiver_id, amount, created_at)
        VALUES ($1, $2, $3, $4)
        RETURNING id
    `

        var transactionID int
        err := pool.QueryRow(ctx, query, transaction.SenderID, transaction.ReceiverID, transaction.Amount, transaction.CreatedAt).Scan(&amp;transactionID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error creating transaction",
                        "error", err,
                        "senderID", transaction.SenderID,
                        "receiverID", transaction.ReceiverID,
                )
                metrics.RecordDBError("CreateTransaction")
                return 0, fmt.Errorf("failed to create transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return transactionID, nil</span>
}

func (r *postgresTransactionRepository) GetTransactionByUserID(ctx context.Context, userID int) ([]*models.Transaction, error) <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                metrics.RecordDBQueryDuration("GetTransactionByUserID", time.Since(start).Seconds())
        }</span>()

        <span class="cov0" title="0">pool := r.conn.GetExecutor(ctx)

        query := `
        SELECT id, sender_id, receiver_id, amount, created_at
        FROM transactions
        WHERE sender_id = $1 OR receiver_id = $1
    `

        rows, err := pool.Query(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error retrieving transaction list",
                        "error", err,
                        "userID", userID,
                )
                metrics.RecordDBError("GetTransactionByUserID")
                return nil, fmt.Errorf("failed to retrieve transaction list: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var transactions []*models.Transaction
        for rows.Next() </span><span class="cov0" title="0">{
                var transaction models.Transaction
                err := rows.Scan(
                        &amp;transaction.ID,
                        &amp;transaction.SenderID,
                        &amp;transaction.ReceiverID,
                        &amp;transaction.Amount,
                        &amp;transaction.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Errorw("Error scanning transaction data",
                                "error", err,
                        )
                        metrics.RecordDBError("GetTransactionByUserID")
                        return nil, fmt.Errorf("error reading transaction data: %w", err)
                }</span>
                <span class="cov0" title="0">transactions = append(transactions, &amp;transaction)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error processing query result",
                        "error", err,
                )
                metrics.RecordDBError("GetTransactionByUserID")
                return nil, fmt.Errorf("error processing query result: %w", err)
        }</span>

        <span class="cov0" title="0">return transactions, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package postgres

import (
        "avito-tech-merch/internal/storage/db"
        "avito-tech-merch/pkg/logger"
        "context"
        "errors"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
)

var (
        IsolationLevelSerializable   = pgx.Serializable
        IsolationLevelReadCommitted  = pgx.ReadCommitted
        IsolationLevelRepeatableRead = pgx.RepeatableRead

        AccessModeReadWrite = pgx.ReadWrite
        AccessModeReadOnly  = pgx.ReadOnly
)

type txKey struct{}

type postgresTxManager struct {
        pool   *pgxpool.Pool
        logger logger.Logger
}

func NewTxManager(pool *pgxpool.Pool, log logger.Logger) db.TxManager <span class="cov0" title="0">{
        return &amp;postgresTxManager{pool: pool, logger: log}
}</span>

func (t *postgresTxManager) GetExecutor(ctx context.Context) db.Executor <span class="cov0" title="0">{
        if tx, ok := ctx.Value(txKey{}).(db.Executor); ok </span><span class="cov0" title="0">{
                return tx
        }</span>
        <span class="cov0" title="0">return t.pool</span>
}

func (t *postgresTxManager) WithTx(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error) error <span class="cov0" title="0">{
        opts := pgx.TxOptions{
                IsoLevel:   isoLevel,
                AccessMode: accessMode,
        }

        var err error

        tx, err := t.pool.BeginTx(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                t.logger.Errorw("Failed to begin transaction",
                        "error", err,
                )
                return err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if rollbackErr := tx.Rollback(ctx); rollbackErr != nil &amp;&amp; !errors.Is(rollbackErr, pgx.ErrTxClosed) </span><span class="cov0" title="0">{
                                t.logger.Errorw("Failed to rollback transaction",
                                        "error", err,
                                )
                        }</span>
                }

        }()

        <span class="cov0" title="0">ctx = context.WithValue(ctx, txKey{}, tx)
        if err = fn(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = tx.Commit(ctx)
        if err != nil </span><span class="cov0" title="0">{
                t.logger.Errorw("Failed to commit transaction",
                        "error", err,
                )
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package postgres

import (
        "avito-tech-merch/internal/metrics"
        "avito-tech-merch/internal/models"
        "avito-tech-merch/internal/storage/db"
        "avito-tech-merch/pkg/logger"
        "context"
        "fmt"
        "time"
)

type postgresUserRepository struct {
        conn   db.TxManager
        logger logger.Logger
}

func NewUserRepository(conn db.TxManager, log logger.Logger) db.UserRepository <span class="cov0" title="0">{
        return &amp;postgresUserRepository{conn: conn, logger: log}
}</span>

func (r *postgresUserRepository) CreateUser(ctx context.Context, user *models.User) (int, error) <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                metrics.RecordDBQueryDuration("CreateUser", time.Since(start).Seconds())
        }</span>()

        <span class="cov0" title="0">pool := r.conn.GetExecutor(ctx)

        query := `
                INSERT INTO users (username, password_hash, balance, created_at)
                VALUES ($1, $2, $3, $4)
                RETURNING id
        `

        user.CreatedAt = time.Now()

        var userID int
        err := pool.QueryRow(ctx, query, user.Username, user.PasswordHash, user.Balance, user.CreatedAt).Scan(&amp;userID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error when creating a user",
                        "error", err,
                        "username", user.Username,
                )
                metrics.RecordDBError("CreateUser")
                return 0, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov0" title="0">return userID, nil</span>
}

func (r *postgresUserRepository) GetUserByID(ctx context.Context, userID int) (*models.User, error) <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                metrics.RecordDBQueryDuration("GetUserByID", time.Since(start).Seconds())
        }</span>()

        <span class="cov0" title="0">pool := r.conn.GetExecutor(ctx)

        query := `
                SELECT id, username, password_hash, balance, created_at
                FROM users
                WHERE id = $1
        `

        var user models.User
        err := pool.QueryRow(ctx, query, userID).Scan(
                &amp;user.ID,
                &amp;user.Username,
                &amp;user.PasswordHash,
                &amp;user.Balance,
                &amp;user.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error when getting a user by ID",
                        "error", err,
                        "userID", userID,
                )
                metrics.RecordDBError("GetUserByID")
                return nil, fmt.Errorf("failed to get a user by ID: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *postgresUserRepository) GetUserByUsername(ctx context.Context, username string) (*models.User, error) <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                metrics.RecordDBQueryDuration("GetUserByUsername", time.Since(start).Seconds())
        }</span>()

        <span class="cov0" title="0">pool := r.conn.GetExecutor(ctx)

        query := `
                SELECT id, username, password_hash, balance, created_at
                FROM users
                WHERE username = $1
        `

        var user models.User
        err := pool.QueryRow(ctx, query, username).Scan(
                &amp;user.ID,
                &amp;user.Username,
                &amp;user.PasswordHash,
                &amp;user.Balance,
                &amp;user.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Warnw("Error when getting a user by username",
                        "error", err,
                        "username", username,
                )
                metrics.RecordDBError("GetUserByUsername")
                return nil, fmt.Errorf("failed to get a user by username: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *postgresUserRepository) GetBalanceByID(ctx context.Context, userID int) (int, error) <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                metrics.RecordDBQueryDuration("GetBalanceByID", time.Since(start).Seconds())
        }</span>()
        <span class="cov0" title="0">pool := r.conn.GetExecutor(ctx)

        query := `
                SELECT balance
                FROM users
                WHERE id = $1
        `

        var balance int
        err := pool.QueryRow(ctx, query, userID).Scan(&amp;balance)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error when getting a user balance by userID",
                        "error", err,
                        "userID", userID)
                metrics.RecordDBError("GetBalanceByID")
                return 0, fmt.Errorf("failed to get a user balance by userID: %w", err)
        }</span>

        <span class="cov0" title="0">return balance, nil</span>
}

func (r *postgresUserRepository) GetBalanceByName(ctx context.Context, username string) (int, error) <span class="cov0" title="0">{
        pool := r.conn.GetExecutor(ctx)

        query := `
                SELECT balance
                FROM users
                WHERE id = $1
        `

        var balance int
        err := pool.QueryRow(ctx, query, username).Scan(&amp;balance)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error when getting a user balance by username",
                        "error", err,
                        "username", username)
                return 0, fmt.Errorf("failed to get a user balance by username: %w", err)
        }</span>

        <span class="cov0" title="0">return balance, nil</span>
}

func (r *postgresUserRepository) UpdateBalance(ctx context.Context, userID int, newBalance int) error <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                metrics.RecordDBQueryDuration("UpdateBalance", time.Since(start).Seconds())
        }</span>()

        <span class="cov0" title="0">pool := r.conn.GetExecutor(ctx)

        query := `
                UPDATE users
                SET balance = $1
                WHERE id = $2
        `

        result, err := pool.Exec(ctx, query, newBalance, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error when updating a user balance",
                        "error", err,
                        "userID", userID,
                        "newBalance", newBalance,
                )
                metrics.RecordDBError("UpdateBalance")
                return fmt.Errorf("failed to update user balance: %w", err)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected() == 0 </span><span class="cov0" title="0">{
                r.logger.Warnw("User not found",
                        "userID", userID,
                )
                return fmt.Errorf("user with ID %d not found", userID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *postgresUserRepository) GetAllUsers(ctx context.Context) ([]*models.User, error) <span class="cov0" title="0">{
        pool := r.conn.GetExecutor(ctx)

        query := `
                SELECT id, username, password_hash, balance, created_at
                FROM users
        `

        rows, err := pool.Query(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error retrieving user list",
                        "error", err,
                )
                return nil, fmt.Errorf("failed to retrieve user list: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []*models.User
        for rows.Next() </span><span class="cov0" title="0">{
                var user models.User
                err := rows.Scan(
                        &amp;user.ID,
                        &amp;user.Username,
                        &amp;user.PasswordHash,
                        &amp;user.Balance,
                        &amp;user.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Errorw("Error scanning user data",
                                "error", err,
                        )
                        return nil, fmt.Errorf("error reading user data: %w", err)
                }</span>
                <span class="cov0" title="0">users = append(users, &amp;user)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error processing query result",
                        "error", err,
                )
                return nil, fmt.Errorf("error processing query result: %w", err)
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

func (r *postgresUserRepository) UpdateUser(ctx context.Context, user *models.User) error <span class="cov0" title="0">{
        pool := r.conn.GetExecutor(ctx)

        query := `
                UPDATE users
                SET username = $1, password_hash = $2, balance = $3
                WHERE id = $4
        `

        result, err := pool.Exec(ctx, query, user.Username, user.PasswordHash, user.Balance, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Errorw("Error updating user data",
                        "error", err,
                        "userID", user.ID,
                )
                return fmt.Errorf("failed to update user data: %w", err)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected() == 0 </span><span class="cov0" title="0">{
                r.logger.Warnw("User not found",
                        "userID", user.ID,
                )
                return fmt.Errorf("user with ID %d not found", user.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package db

import (
        "avito-tech-merch/internal/models"
        "context"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type Repository interface {
        UserRepository
        MerchRepository
        PurchaseRepository
        TransactionRepository
}

type UserRepository interface {
        CreateUser(ctx context.Context, user *models.User) (int, error)
        GetUserByID(ctx context.Context, userID int) (*models.User, error)
        GetUserByUsername(ctx context.Context, username string) (*models.User, error)
        GetBalanceByID(ctx context.Context, userID int) (int, error)
        GetBalanceByName(ctx context.Context, username string) (int, error)
        UpdateBalance(ctx context.Context, userID int, newBalance int) error
        GetAllUsers(ctx context.Context) ([]*models.User, error)
        UpdateUser(ctx context.Context, user *models.User) error
}

type MerchRepository interface {
        GetAllMerch(ctx context.Context) ([]*models.Merch, error)
        GetMerchByID(ctx context.Context, id int) (*models.Merch, error)
        GetMerchByName(ctx context.Context, merchName string) (*models.Merch, error)
}

type PurchaseRepository interface {
        CreatePurchase(ctx context.Context, purchase *models.Purchase) (int, error)
        GetPurchaseByUserID(ctx context.Context, userID int) ([]*models.Purchase, error)
}

type TransactionRepository interface {
        CreateTransaction(ctx context.Context, transaction *models.Transaction) (int, error)
        GetTransactionByUserID(ctx context.Context, userID int) ([]*models.Transaction, error)
}

type Executor interface {
        Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error)
        Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)
        QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
}

type TxManager interface {
        GetExecutor(ctx context.Context) Executor
        WithTx(ctx context.Context, isoLevel pgx.TxIsoLevel, accessMode pgx.TxAccessMode, fn func(ctx context.Context) error) error
}

type postgresRepository struct {
        UserRepository
        MerchRepository
        PurchaseRepository
        TransactionRepository
}

func NewRepository(
        userRepo UserRepository,
        merchRepo MerchRepository,
        purchaseRepo PurchaseRepository,
        transactionRepo TransactionRepository,
) Repository <span class="cov0" title="0">{
        return &amp;postgresRepository{
                UserRepository:        userRepo,
                MerchRepository:       merchRepo,
                PurchaseRepository:    purchaseRepo,
                TransactionRepository: transactionRepo,
        }
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package jwt

import (
        "fmt"
        "github.com/golang-jwt/jwt/v5"
        "time"
)

type TokenService interface {
        GenerateToken(userID int, secretKey string, expirationTime int) (string, error)
        ParseJWTToken(tokenString, secretKey string) (int, error)
}

type TokenServiceImpl struct {
}

func NewTokenService() TokenService <span class="cov0" title="0">{
        return &amp;TokenServiceImpl{}
}</span>

func (t *TokenServiceImpl) GenerateToken(userID int, secretKey string, expirationTime int) (string, error) <span class="cov0" title="0">{
        now := time.Now()

        expiration := now.Add(time.Duration(expirationTime) * time.Second)

        claims := jwt.MapClaims{
                "user_id": userID,
                "exp":     expiration.Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        return token.SignedString([]byte(secretKey))
}</span>

func (t *TokenServiceImpl) ParseJWTToken(tokenString, secretKey string) (int, error) <span class="cov0" title="0">{
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(secretKey), nil
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                userID := int(claims["user_id"].(float64))
                return userID, nil
        }</span>

        <span class="cov0" title="0">return 0, fmt.Errorf("invalid token")</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Code generated by mockery v2.53.0. DO NOT EDIT.

package mock

import mock "github.com/stretchr/testify/mock"

// TokenService is an autogenerated mock type for the TokenService type
type TokenService struct {
        mock.Mock
}

// GenerateToken provides a mock function with given fields: userID, secretKey, expirationTime
func (_m *TokenService) GenerateToken(userID int, secretKey string, expirationTime int) (string, error) <span class="cov0" title="0">{
        ret := _m.Called(userID, secretKey, expirationTime)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GenerateToken")</span>
        }

        <span class="cov0" title="0">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(int, string, int) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(userID, secretKey, expirationTime)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(int, string, int) string); ok </span><span class="cov0" title="0">{
                r0 = rf(userID, secretKey, expirationTime)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(int, string, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(userID, secretKey, expirationTime)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// ParseJWTToken provides a mock function with given fields: tokenString, secretKey
func (_m *TokenService) ParseJWTToken(tokenString string, secretKey string) (int, error) <span class="cov0" title="0">{
        ret := _m.Called(tokenString, secretKey)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ParseJWTToken")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(string, string) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(tokenString, secretKey)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string, string) int); ok </span><span class="cov0" title="0">{
                r0 = rf(tokenString, secretKey)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(tokenString, secretKey)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewTokenService creates a new instance of TokenService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTokenService(t interface {
        mock.TestingT
        Cleanup(func())
}) *TokenService <span class="cov0" title="0">{
        mock := &amp;TokenService{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package logger

import (
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

type Logger interface {
        Debug(msg string, fields ...zap.Field)
        Info(msg string, fields ...zap.Field)
        Warn(msg string, fields ...zap.Field)
        Error(msg string, fields ...zap.Field)
        Fatal(msg string, fields ...zap.Field)
        Debugw(msg string, keysAndValues ...interface{})
        Infow(msg string, keysAndValues ...interface{})
        Warnw(msg string, keysAndValues ...interface{})
        Errorw(msg string, keysAndValues ...interface{})
        Fatalw(msg string, keysAndValues ...interface{})
        Sync()
}

type ZapLogger struct {
        logger *zap.Logger
        sugar  *zap.SugaredLogger
}

func NewLogger(mode string) Logger <span class="cov0" title="0">{
        var config zap.Config

        switch mode </span>{
        case "dev":<span class="cov0" title="0">
                config = zap.NewDevelopmentConfig()
                config.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
                config.EncoderConfig.TimeKey = "timestamp"
                config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder

                // отвечает за caller и автовывод стека
                config.EncoderConfig.CallerKey = ""
                config.DisableStacktrace = true</span>
        case "prod":<span class="cov0" title="0">
                config = zap.NewProductionConfig()
                config.EncoderConfig.EncodeLevel = zapcore.LowercaseLevelEncoder
                config.EncoderConfig.TimeKey = "timestamp"
                config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder</span>
        default:<span class="cov0" title="0">
                panic("unknown log mode")</span>
        }

        <span class="cov0" title="0">logger, err := config.Build()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return &amp;ZapLogger{
                logger: logger,
                sugar:  logger.Sugar(),
        }</span>
}

func (l *ZapLogger) Debug(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.logger.Debug(msg, fields...)
}</span>

func (l *ZapLogger) Info(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.logger.Info(msg, fields...)
}</span>

func (l *ZapLogger) Warn(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.logger.Warn(msg, fields...)
}</span>

func (l *ZapLogger) Error(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.logger.Error(msg, fields...)
}</span>

func (l *ZapLogger) Fatal(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.logger.Fatal(msg, fields...)
}</span>

func (l *ZapLogger) Debugw(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.sugar.Debugw(msg, keysAndValues...)
}</span>

func (l *ZapLogger) Infow(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.sugar.Infow(msg, keysAndValues...)
}</span>

func (l *ZapLogger) Warnw(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.sugar.Warnw(msg, keysAndValues...)
}</span>

func (l *ZapLogger) Errorw(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.sugar.Errorw(msg, keysAndValues...)
}</span>

func (l *ZapLogger) Fatalw(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.sugar.Fatalw(msg, keysAndValues...)
}</span>

func (l *ZapLogger) Sync() <span class="cov0" title="0">{
        _ = l.logger.Sync()
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">// Code generated by mockery v2.53.0. DO NOT EDIT.

package mock

import (
        mock "github.com/stretchr/testify/mock"
        zapcore "go.uber.org/zap/zapcore"
)

// Logger is an autogenerated mock type for the Logger type
type Logger struct {
        mock.Mock
}

// Debug provides a mock function with given fields: msg, fields
func (_m *Logger) Debug(msg string, fields ...zapcore.Field) <span class="cov0" title="0">{
        _va := make([]interface{}, len(fields))
        for _i := range fields </span><span class="cov0" title="0">{
                _va[_i] = fields[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, msg)
        _ca = append(_ca, _va...)
        _m.Called(_ca...)</span>
}

// Debugw provides a mock function with given fields: msg, keysAndValues
func (_m *Logger) Debugw(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, msg)
        _ca = append(_ca, keysAndValues...)
        _m.Called(_ca...)
}</span>

// Error provides a mock function with given fields: msg, fields
func (_m *Logger) Error(msg string, fields ...zapcore.Field) <span class="cov0" title="0">{
        _va := make([]interface{}, len(fields))
        for _i := range fields </span><span class="cov0" title="0">{
                _va[_i] = fields[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, msg)
        _ca = append(_ca, _va...)
        _m.Called(_ca...)</span>
}

// Errorw provides a mock function with given fields: msg, keysAndValues
func (_m *Logger) Errorw(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, msg)
        _ca = append(_ca, keysAndValues...)
        _m.Called(_ca...)
}</span>

// Fatal provides a mock function with given fields: msg, fields
func (_m *Logger) Fatal(msg string, fields ...zapcore.Field) <span class="cov0" title="0">{
        _va := make([]interface{}, len(fields))
        for _i := range fields </span><span class="cov0" title="0">{
                _va[_i] = fields[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, msg)
        _ca = append(_ca, _va...)
        _m.Called(_ca...)</span>
}

// Fatalw provides a mock function with given fields: msg, keysAndValues
func (_m *Logger) Fatalw(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, msg)
        _ca = append(_ca, keysAndValues...)
        _m.Called(_ca...)
}</span>

// Info provides a mock function with given fields: msg, fields
func (_m *Logger) Info(msg string, fields ...zapcore.Field) <span class="cov0" title="0">{
        _va := make([]interface{}, len(fields))
        for _i := range fields </span><span class="cov0" title="0">{
                _va[_i] = fields[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, msg)
        _ca = append(_ca, _va...)
        _m.Called(_ca...)</span>
}

// Infow provides a mock function with given fields: msg, keysAndValues
func (_m *Logger) Infow(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, msg)
        _ca = append(_ca, keysAndValues...)
        _m.Called(_ca...)
}</span>

// Sync provides a mock function with no fields
func (_m *Logger) Sync() <span class="cov0" title="0">{
        _m.Called()
}</span>

// Warn provides a mock function with given fields: msg, fields
func (_m *Logger) Warn(msg string, fields ...zapcore.Field) <span class="cov0" title="0">{
        _va := make([]interface{}, len(fields))
        for _i := range fields </span><span class="cov0" title="0">{
                _va[_i] = fields[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, msg)
        _ca = append(_ca, _va...)
        _m.Called(_ca...)</span>
}

// Warnw provides a mock function with given fields: msg, keysAndValues
func (_m *Logger) Warnw(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, msg)
        _ca = append(_ca, keysAndValues...)
        _m.Called(_ca...)
}</span>

// NewLogger creates a new instance of Logger. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLogger(t interface {
        mock.TestingT
        Cleanup(func())
}) *Logger <span class="cov0" title="0">{
        mock := &amp;Logger{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package password

import "golang.org/x/crypto/bcrypt"

func HashPassword(password string) (string, error) <span class="cov8" title="1">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(hashedPassword), nil</span>
}

func CheckPassword(hashedPassword, password string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package testutil

import (
        "database/sql"
        "fmt"
        _ "github.com/lib/pq"
        "github.com/pressly/goose/v3"
)

func RunMigrations(dbDSN, migrationsDir string) error <span class="cov0" title="0">{
        db, err := sql.Open("postgres", dbDSN)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("sql.Open: %w", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        if err := goose.SetDialect("postgres"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("goose.SetDialect: %w", err)
        }</span>

        <span class="cov0" title="0">if err := goose.Up(db, migrationsDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("goose.Up: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package testutil

import (
        "context"
        "fmt"
        "github.com/docker/go-connections/nat"
        "github.com/testcontainers/testcontainers-go"
        "github.com/testcontainers/testcontainers-go/wait"
)

type (
        PostgreSQLContainer struct {
                testcontainers.Container
                Config PostgreSQLContainerConfig
        }

        PostgreSQLContainerOption func(c *PostgreSQLContainerConfig)

        PostgreSQLContainerConfig struct {
                ImageTag   string
                User       string
                Password   string
                MappedPort string
                Database   string
                Host       string
        }
)

func (c *PostgreSQLContainer) GetDSN() string <span class="cov0" title="0">{
        return fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable", c.Config.User, c.Config.Password, c.Config.Host, c.Config.MappedPort, c.Config.Database)
}</span>

func NewPostgreSQLContainer(ctx context.Context, opts ...PostgreSQLContainerOption) (*PostgreSQLContainer, error) <span class="cov0" title="0">{
        const (
                psqlImage = "postgres"
                psqlPort  = "5432"
        )

        config := PostgreSQLContainerConfig{
                ImageTag: "latest",
                User:     "champ001",
                Password: "123champ123",
                Database: "merch-store_test",
        }
        //handle possible options
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(&amp;config)
        }</span>

        <span class="cov0" title="0">containerPort := psqlPort + "/tcp"

        req := testcontainers.GenericContainerRequest{
                ContainerRequest: testcontainers.ContainerRequest{
                        Env: map[string]string{
                                "POSTGRES_USER":     config.User,
                                "POSTGRES_PASSWORD": config.Password,
                                "POSTGRES_DB":       config.Database,
                        },
                        ExposedPorts: []string{
                                containerPort,
                        },
                        Image:      fmt.Sprintf("%s:%s", psqlImage, config.ImageTag),
                        WaitingFor: wait.ForListeningPort(nat.Port(containerPort)),
                },
                Started: true,
        }

        container, err := testcontainers.GenericContainer(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("getting request provider: %w", err)
        }</span>

        <span class="cov0" title="0">host, err := container.Host(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("getting host for: %w", err)
        }</span>

        <span class="cov0" title="0">mappedPort, err := container.MappedPort(ctx, nat.Port(containerPort))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("getting mapped port for (%s): %w", containerPort, err)
        }</span>
        <span class="cov0" title="0">config.MappedPort = mappedPort.Port()
        config.Host = host

        fmt.Println("Host:", config.Host, config.MappedPort)

        return &amp;PostgreSQLContainer{
                Container: container,
                Config:    config,
        }, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
